<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>廃洋館チェイス - 本制作版</title>
<style>
  :root{
    --bg:#0b0b10;
    --ui:#eaeaea;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif; -webkit-user-select:none; -ms-user-select:none; user-select:none;}
  canvas{display:block;background:#0b0b0f}
  /* Overlays */
  #landscapeBlock{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;font-size:20px;z-index:100;color:#fff}
  /* Start / Select */
  #startUI{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:90;background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.9))}
  .panel{background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);max-width:92%;width:520px;text-align:center}
  .roles{display:flex;gap:10px;justify-content:center;margin-top:12px}
  .role{flex:1;padding:10px;border-radius:8px;cursor:pointer;border:2px solid rgba(255,255,255,0.04)}
  .role.selected{border-color:#ffd166;background:rgba(255,209,102,0.06)}
  button{padding:8px 14px;border-radius:8px;border:none;background:#ffd166;color:#111;font-weight:700;cursor:pointer}
  #hud{position:fixed;left:12px;top:12px;z-index:40;display:flex;gap:10px;align-items:center}
  #status{font-size:14px;color:#ddd}
  #actionHint{position:fixed;right:18px;bottom:18px;width:86px;height:86px;border-radius:44px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:700;z-index:40;color:#fff;pointer-events:none}
  #hintSmall{position:fixed;left:12px;bottom:12px;font-size:13px;color:#cfcfcf;z-index:40}
</style>
</head>
<body>
  <div id="landscapeBlock">横画面（ランドスケープ）でプレイしてください</div>

  <div id="startUI">
    <div class="panel" role="dialog" aria-modal="true">
      <h2 style="margin:0 0 8px 0">廃洋館チェイス — 開始</h2>
      <p style="margin:0 0 12px 0;color:#ccc">役職を選んで「開始」を押してください。最初のタップでサウンドとBGMが有効になります。</p>

      <div style="display:flex;gap:10px;align-items:center;justify-content:center;margin-bottom:12px">
        <div style="text-align:left">
          <div style="font-weight:700">逃走者（選択）</div>
          <div style="font-size:13px;color:#bbb">役割毎に特性が異なります。</div>
        </div>
      </div>

      <div class="roles">
        <div class="role" id="role-sprinter" data-role="sprinter">
          <div style="font-weight:800">スプリンター</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">高速移動・短ダッシュ</div>
        </div>

        <div class="role" id="role-hacker" data-role="hacker">
          <div style="font-weight:800">ハッカー</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">パズル処理が早い</div>
        </div>

        <div class="role" id="role-trick" data-role="trickster">
          <div style="font-weight:800">トリックスター</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">足音を偽装・撹乱に長ける</div>
        </div>
      </div>

      <div style="margin-top:14px">
        <button id="startBtn">開始する</button>
      </div>

      <div style="margin-top:10px;font-size:12px;color:#bbb">制作版：サウンド・BGM・長めのパズル・個性あるキャラに対応</div>
    </div>
  </div>

  <div id="hud">
    <div id="status">準備中</div>
  </div>
  <div id="actionHint">Action</div>
  <div id="hintSmall">左下スティックで移動、右下でAction（パズルを開く）</div>

  <canvas id="game"></canvas>

<script>
/* ------------------------------
   廃洋館チェイス — 本制作版
   - 横画面必須（ポートレートは操作ブロック）
   - スタートでAudioContext開始（BGM/SFX）
   - 3役職選択（プレイヤー）＋2 AI味方
   - 追跡者（鬼）1体
   - パズル：Simon(7手) → 三角整列
   - 障害物多数、カメラ追従、アイソメ描画
   ------------------------------ */

/* ======== 基本セットアップ ======== */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', {alpha:false});
let W = innerWidth, H = innerHeight;
function resize(){
  W = innerWidth; H = innerHeight;
  canvas.width = W; canvas.height = H;
  stickBase.x = 110; stickBase.y = H - 110;
  actionArea.x = W - 110; actionArea.y = H - 110;
  updateLandscapeBlock();
}
window.addEventListener('resize', resize);
resize();

const landscapeBlock = document.getElementById('landscapeBlock');
function updateLandscapeBlock(){
  if(W > H) landscapeBlock.style.display = 'none';
  else landscapeBlock.style.display = 'flex';
}
updateLandscapeBlock();

/* ======== オーディオ ======== */
let audioCtx = null;
let bgmGain = null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  bgmGain = audioCtx.createGain(); bgmGain.gain.value = 0.16; bgmGain.connect(audioCtx.destination);
  startBGM();
}
let bgmInterval = null;
function startBGM(){
  if(!audioCtx) return;
  // simple evolving arpeggio loop
  const base = [440,523.25,659.25,783.99]; // A4,C5,E5,G5
  const step = 0.5;
  let t0 = audioCtx.currentTime + 0.05;
  function schedule(){
    for(let i=0;i<base.length;i++){
      const t = t0 + i*step;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine'; o.frequency.value = base[(i)%base.length] * (1 + 0.02*Math.sin(t0+i));
      g.gain.value = 0.0001;
      o.connect(g); g.connect(bgmGain);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.08, t+0.02);
      g.gain.linearRampToValueAtTime(0.0001, t+step-0.02);
      o.start(t); o.stop(t+step);
    }
    t0 += base.length*step;
  }
  schedule();
  bgmInterval = setInterval(schedule, base.length*step*1000);
}

// simple SFX generator
function playSFX(name){
  if(!audioCtx) return;
  const now = audioCtx.currentTime;
  if(name==='step'){
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type='square'; o.frequency.value = 300 + Math.random()*80;
    g.gain.value = 0.0001;
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.exponentialRampToValueAtTime(0.05, now+0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
    o.start(now); o.stop(now+0.18);
  } else if(name==='open'){
    const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value = 520;
    const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.06, now+0.02); g.gain.linearRampToValueAtTime(0.0001, now+0.36);
    o.start(now); o.stop(now+0.36);
  } else if(name==='success'){
    const freqs = [660,880,990];
    freqs.forEach((f, i)=>{
      const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
      o.type='sine'; o.frequency.value = f;
      o.connect(g); g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.0001, now + i*0.02);
      g.gain.linearRampToValueAtTime(0.08, now + 0.06 + i*0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 1.0);
      o.start(now + i*0.02); o.stop(now + 1.0);
    });
  } else if(name==='fail'){
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type='sawtooth'; o.frequency.value = 160;
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
    o.start(now); o.stop(now+0.6);
  } else if(name==='caught'){
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain();
    o.type='square'; o.frequency.value = 120;
    o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.18, now+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, now+1.2);
    o.start(now); o.stop(now+1.2);
  }
}

/* ======== 世界定義（グリッド） ======== */
const worldSize = 30;
const tile = 56;
const maxX = worldSize - 1, maxY = worldSize - 1;

/* アイソメ変換 */
function iso(x,y,camera){ return { x:(x-y)*tile/2 - camera.x + W/2, y:(x+y)*tile/4 - camera.y + H/3 }; }

/* ======== マップ（障害物） ======== */
let obstacles = [];
function generateObstacles(){
  obstacles = [];
  const count = 36;
  for(let i=0;i<count;i++){
    let ox,oy,tries=0;
    do{
      ox = Math.floor(Math.random()*worldSize);
      oy = Math.floor(Math.random()*worldSize);
      tries++;
    } while(((ox<=3 && oy<=3) || (ox>=worldSize-4 && oy>=worldSize-4) || (ox===15 && oy===15)) && tries<200);
    if(!obstacles.some(o=>o.x===ox && o.y===oy)) obstacles.push({x:ox,y:oy});
  }
}
generateObstacles();

/* ======== キャラクター（3逃走者 + 追跡者） ======== */
/* 役職特性 */
const roles = {
  sprinter: {name:'スプリンター', color:'#17dbe6', speed:0.14, dashAvail:true, puzzleSpeedMult:1.0, trait:'高速移動'},
  hacker:  {name:'ハッカー', color:'#ffd166', speed:0.10, dashAvail:false, puzzleSpeedMult:0.6, trait:'パズル得意'},
  trickster:{name:'トリックスター', color:'#7ad07a', speed:0.11, dashAvail:false, puzzleSpeedMult:0.95, trait:'偽音で撹乱'}
};

// AI仲間（2）とプレイヤー（後に選択されたrole）
let allies = [
  {id:1, role:null, x:4, y:5, speed:0.11, ai:true},
  {id:2, role:null, x:5, y:4, speed:0.11, ai:true}
];
let player = {id:0, role:null, x:3, y:3, speed:0.12, dash:false, dashTimer:0};
let chaser = {x:26, y:26, speed:0.07, lockUsed:false};

/* カメラ */
let camera = {x:0,y:0};

/* ======== UI / 操作（固定スティック & Action） ======== */
const stickBase = {x:110, y: H - 110};
const stickRadius = 60;
const knobRadius = 28;
let stickState = {active:false, dx:0, dy:0, id:null};

const actionArea = {x: W - 110, y: H - 110, r:42};
let actionState = {active:false, id:null};

/* pointer events */
function dist(a,b,c,d){return Math.hypot(a-c,b-d);}
canvas.addEventListener('pointerdown', e=>{
  if(!(W>H)) return;
  const px=e.clientX, py=e.clientY;
  // left stick area
  if(dist(px,py,stickBase.x,stickBase.y) < stickRadius+20 && !stickState.active){
    stickState.active=true; stickState.id=e.pointerId; updateStick(px,py);
  } else if(dist(px,py,actionArea.x,actionArea.y) < actionArea.r+10){
    // action pressed
    handleAction();
    actionState.active=true; actionState.id=e.pointerId;
  } else if(puzzle.active){
    // if puzzle overlay is active, handle overlay tap (Simon / triangles)
    puzzlePointerDown(px,py);
  }
});
canvas.addEventListener('pointermove', e=>{
  if(stickState.active && e.pointerId===stickState.id) updateStick(e.clientX, e.clientY);
});
canvas.addEventListener('pointerup', e=>{
  if(stickState.active && e.pointerId===stickState.id){ stickState.active=false; stickState.id=null; stickState.dx=0; stickState.dy=0; }
  if(actionState.active && e.pointerId===actionState.id){ actionState.active=false; actionState.id=null; }
});

function updateStick(px,py){
  let dx = px - stickBase.x, dy = py - stickBase.y;
  const len = Math.hypot(dx,dy);
  if(len > stickRadius){ dx = dx/len*stickRadius; dy = dy/len*stickRadius; }
  stickState.dx = dx; stickState.dy = dy;
}

/* ======== パズル（Simon長め → 三角整列） ======== */
const puzzle = {x:15,y:15, solved:false, active:false};
let simonSeq = [], simonIndex=0, simonPlayerIndex=0, currentHighlight=-1;
const SIMON_LENGTH = 7; // やや長めで時間が掛かる
const simonPads = [{color:'#ff7a7a'},{color:'#ffd47a'},{color:'#7ad0ff'},{color:'#7affb3'}];
let triangles = [{angle:90},{angle:180},{angle:270}];

function isNearPuzzle(){
  return Math.hypot(player.x - puzzle.x, player.y - puzzle.y) < 1.8;
}
function startPuzzle(){
  if(puzzle.solved || puzzle.active) return;
  puzzle.active = true; playSFX('open');
  // generate Simon seq
  simonSeq = []; for(let i=0;i<SIMON_LENGTH;i++) simonSeq.push(Math.floor(Math.random()*4));
  simonIndex = 0; simonPlayerIndex = 0; currentHighlight = -1;
  // triangles randomized
  triangles.forEach(t=> t.angle = (Math.floor(Math.random()*4)*90));
  // start display sequence shortly
  setTimeout(()=> playSimonStep(), 500);
}
function playSimonStep(){
  if(simonIndex >= simonSeq.length){ simonIndex = -1; currentHighlight=-1; playSFX('success'); return; }
  const pad = simonSeq[simonIndex];
  currentHighlight = pad; playSFX('open');
  setTimeout(()=> { currentHighlight = -1; simonIndex++; setTimeout(()=> playSimonStep(), 420); }, 420);
}
function playerPressPad(id){
  playSFX('step');
  if(simonIndex === -1) return; // Simon phase done
  if(id === simonSeq[simonPlayerIndex]){ simonPlayerIndex++; if(simonPlayerIndex >= simonSeq.length){ simonIndex = -1; simonPlayerIndex=0; playSFX('success'); } }
  else { playSFX('fail'); simonPlayerIndex=0; setTimeout(()=> playSimonStep(), 600); }
}
function puzzlePointerDown(px,py){
  // if Simon still active: see pads center
  const cx = W/2, cy = H/2 - 40;
  if(simonIndex !== -1){
    for(let i=0;i<4;i++){
      const px_i = cx + (i-1.5)*120, py_i = cy;
      if(dist(px,py,px_i,py_i) < 52){ playerPressPad(i); break; }
    }
  } else {
    // triangles interaction
    for(let i=0;i<3;i++){
      const tx = W/2 + (i-1)*140, ty = cy + 40;
      if(dist(px,py,tx,ty) < 70){ triangles[i].angle = (triangles[i].angle + 90) % 360; playSFX('step'); checkTriangles(); break; }
    }
  }
}
function checkTriangles(){
  if(triangles.every(t=> ((t.angle%360 + 360)%360) === 0)){
    puzzle.solved = true; puzzle.active = false; document.getElementById('status').textContent = 'パズル解除！'; playSFX('success');
  }
}

/* ======== AI味方（簡易） ======== */
function setupAllies(selectedRole){
  // assign roles: one allied gets hacker if player not hacker
  const keys = Object.keys(roles);
  // ensure variety: if player is hacker, allies get other roles
  let available = keys.filter(k=>k!==selectedRole);
  allies.forEach((a,i)=>{
    const rkey = available[i % available.length];
    a.role = rkey; a.speed = roles[rkey].speed * 0.95; a.x = 3 + i + 1; a.y = 3 + (i%2);
  });
  // set player role
  player.role = selectedRole;
  player.speed = roles[selectedRole].speed;
}

/* Allies behavior: wander, assist puzzle (hacker helps finish), help rescue (not implemented heavy) */
function updateAllies(){
  allies.forEach(a=>{
    // if puzzle unsolved, hacker seeks puzzle to help; others roam nearby player
    if(!puzzle.solved && a.role === 'hacker'){
      // move toward puzzle
      const dx = puzzle.x - a.x, dy = puzzle.y - a.y;
      const d = Math.hypot(dx,dy);
      if(d > 0.6){ a.x += (dx/d) * a.speed * 0.9; a.y += (dy/d) * a.speed * 0.9; }
      // when at puzzle, help by speeding up Simon completion occasionally
      if(Math.hypot(a.x - puzzle.x, a.y - puzzle.y) < 1.2 && puzzle.active && simonIndex !== -1){
        // hacker speeds up: skip some steps occasionally
        if(Math.random() < 0.02){ simonIndex = Math.max(0, simonIndex - 1); }
      }
      // also when Simon finished, hacker helps align triangles
      if(Math.hypot(a.x - puzzle.x, a.y - puzzle.y) < 1.2 && simonIndex === -1 && !puzzle.solved){
        // small chance to auto-rotate a triangle
        if(Math.random() < 0.01){ const idx = Math.floor(Math.random()*3); triangles[idx].angle = (triangles[idx].angle + 90) % 360; checkTriangles(); }
      }
    } else {
      // simple follow-player wander
      const dx = player.x - a.x, dy = player.y - a.y; const d = Math.hypot(dx,dy);
      if(d > 1.5){ a.x += (dx/d) * a.speed * 0.9; a.y += (dy/d) * a.speed * 0.9; }
      else { // mild random
        if(Math.random() < 0.01){ a.x += (Math.random()-0.5)*0.2; a.y += (Math.random()-0.5)*0.2; }
      }
    }
    // clamp
    a.x = Math.max(0,Math.min(maxX,a.x)); a.y = Math.max(0,Math.min(maxY,a.y));
  });
}

/* ======== 追跡者（鬼）AI ======== */
let tileLocks = []; // locked tiles {x,y,expires}
function updateChaser(dt){
  // chase nearest alive escapee (player preferable)
  const targets = [player, ...allies];
  let nearest = null; let nd = 9999;
  targets.forEach(t=>{
    const d = Math.hypot(t.x - chaser.x, t.y - chaser.y);
    if(d < nd){ nd = d; nearest = t; }
  });
  if(nearest){
    const dx = nearest.x - chaser.x, dy = nearest.y - chaser.y; const dist = Math.hypot(dx,dy);
    if(dist > 0.05){
      let nx = chaser.x + (dx/dist) * chaser.speed;
      let ny = chaser.y + (dy/dist) * chaser.speed;
      const itx = Math.round(nx), ity = Math.round(ny);
      const blocked = obstacles.some(o=>o.x===itx && o.y===ity) || tileLocks.some(l=>l.x===itx && l.y===ity && l.expires > performance.now());
      if(!blocked){ chaser.x = Math.max(0,Math.min(maxX,nx)); chaser.y = Math.max(0,Math.min(maxY,ny)); }
      else { chaser.x += -dy/(dist+0.001) * chaser.speed*0.6; chaser.y += dx/(dist+0.001) * chaser.speed*0.6; }
    }
    // occasional tile lock ability near player to split
    if(!chaser.lockUsed && Math.random() < 0.0015){ const lx = Math.round(chaser.x), ly = Math.round(chaser.y); tileLocks.push({x:lx,y:ly,expires: performance.now() + 5000}); chaser.lockUsed=true; playSFX('open'); }
  }
  // expire
  tileLocks = tileLocks.filter(l => l.expires > performance.now());
}

/* ======== ユーティリティ：衝突/タイルチェック ======== */
function isTileBlocked(tx,ty){
  if(tx<0 || ty<0 || tx>maxX || ty>maxY) return true;
  return obstacles.some(o=>o.x===tx && o.y===ty) || tileLocks.some(l=>l.x===tx && l.y===ty && l.expires > performance.now());
}

/* ======== 行動：Action押下 ======== */
function handleAction(){
  if(puzzle.solved) return;
  if(isNearPuzzle()){
    if(!puzzle.active) startPuzzle();
  } else {
    // other interactions in future (doors etc.)
    playSFX('open');
  }
}

/* ======== Start UI（役職選択） ======== */
const startUI = document.getElementById('startUI');
let selectedRole = 'sprinter';
document.getElementById('role-sprinter').classList.add('selected');
document.getElementById('role-sprinter').addEventListener('click', ()=> selectRole('sprinter'));
document.getElementById('role-hacker').addEventListener('click', ()=> selectRole('hacker'));
document.getElementById('role-trick').addEventListener('click', ()=> selectRole('trickster'));
function selectRole(key){
  selectedRole = key;
  document.querySelectorAll('.role').forEach(e=>e.classList.remove('selected'));
  document.getElementById('role-'+(key==='trickster'?'trick':'hacker')).classList.remove('selected');
  if(key==='sprinter') document.getElementById('role-sprinter').classList.add('selected');
  if(key==='hacker') document.getElementById('role-hacker').classList.add('selected');
  if(key==='trickster') document.getElementById('role-trick').classList.add('selected');
}
document.getElementById('startBtn').addEventListener('click', ()=>{
  initAudio();
  setupAllies(selectedRole);
  document.getElementById('status').textContent = 'ゲーム中';
  startUI.style.display = 'none';
});

/* ======== 描画：キャラ・世界 ======== */
function drawPlayerVisual(p){
  const pos = iso(p.x,p.y,camera);
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(pos.x-12, pos.y-6, 24, 6);
  // body ellipse color depends on role
  const color = roles[p.role].color;
  ctx.fillStyle = color;
  ctx.beginPath(); ctx.ellipse(pos.x, pos.y-14, 12, 10, 0, 0, Math.PI*2); ctx.fill();
  // head differs per role (cap/scarf/eye)
  if(p.role === 'sprinter'){
    // cap and sports look
    ctx.fillStyle = '#004a59';
    ctx.fillRect(pos.x-8, pos.y-26, 16, 8);
    ctx.fillStyle = '#ffd166';
    ctx.beginPath(); ctx.arc(pos.x, pos.y-22, 6, 0, Math.PI*2); ctx.fill();
  } else if(p.role === 'hacker'){
    ctx.fillStyle = '#333';
    ctx.beginPath(); ctx.rect(pos.x-8, pos.y-26, 16, 8); ctx.fill();
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(pos.x, pos.y-22, 6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.fillRect(pos.x-3.5,pos.y-24,2,2); ctx.fillRect(pos.x+1.5,pos.y-24,2,2);
  } else {
    // trickster: bandana
    ctx.fillStyle = '#fff';
    ctx.beginPath(); ctx.arc(pos.x, pos.y-22, 6, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#7a2bff';
    ctx.fillRect(pos.x-8, pos.y-24, 16, 4);
  }
}
function drawChaserVisual(c){
  const pos = iso(c.x,c.y,camera);
  // shadow
  ctx.fillStyle = 'rgba(0,0,0,0.4)';
  ctx.fillRect(pos.x-14, pos.y-8, 28, 8);
  // cloak body
  ctx.fillStyle = '#6b1f23';
  ctx.beginPath(); ctx.ellipse(pos.x, pos.y-12, 14, 11, 0, 0, Math.PI*2); ctx.fill();
  // eyes
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(pos.x-5,pos.y-18,3.2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(pos.x-5,pos.y-18,1.3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(pos.x+3.5,pos.y-17.5,2.7,0,Math.PI*2); ctx.fill();
  ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(pos.x+3.5,pos.y-17.5,1.0,0,Math.PI*2); ctx.fill();
}

/* ======== メイン更新ループ ======== */
let last = performance.now();
function updateLoop(now){
  const dt = (now - last)/1000; last = now;
  // move player by stick
  if(stickState.active){
    const len = Math.hypot(stickState.dx, stickState.dy);
    if(len > 6){
      // map screen knob dx,dy to approximate world axes (simple mapping)
      const vx = (stickState.dx / stickRadius) * player.speed;
      const vy = (stickState.dy / stickRadius) * player.speed;
      const nx = player.x + vx, ny = player.y + vy;
      const itx = Math.round(nx), ity = Math.round(ny);
      if(!isTileBlocked(itx,ity) && nx>=0 && ny>=0 && nx<=maxX && ny<=maxY){ player.x = nx; player.y = ny; playSFX('step'); }
    }
  }
  // camera follow
  camera.x = (player.x - player.y) * tile/2;
  camera.y = (player.x + player.y) * tile/4;

  // allies
  updateAllies();

  // chaser
  updateChaser(dt);

  // capture check
  const caught = Math.hypot(player.x - chaser.x, player.y - chaser.y) < 0.6;
  if(caught){
    document.getElementById('status').textContent = '捕まった…';
    playSFX('caught');
    // game over: show restart overlay
    showEndScreen(false);
    return; // stop updates until restart
  }

  // puzzle auto-close on leaving
  if(puzzle.active && !isNearPuzzle()) puzzle.active = false;

  // AI: player-controlled hacker helps speed puzzle (handled inside updateAllies)

  render();
  requestAnimationFrame(updateLoop);
}

/* ======== 描画ルーチン ======== */
function render(){
  // clear
  ctx.fillStyle = '#0b0b10';
  ctx.fillRect(0,0,W,H);

  // floor tiles
  for(let gx=0; gx<worldSize; gx++){
    for(let gy=0; gy<worldSize; gy++){
      const p = iso(gx,gy,camera);
      ctx.fillStyle = ((gx+gy)%2===0) ? '#141416' : '#101013';
      ctx.fillRect(p.x, p.y, tile/2, tile/4);
    }
  }

  // obstacles
  obstacles.forEach(o=>{
    const p = iso(o.x,o.y,camera);
    ctx.fillStyle = '#5c4f3f';
    ctx.fillRect(p.x-4, p.y-28, 36, 28);
    ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fillRect(p.x-4, p.y-28, 36, 6);
  });

  // tile locks
  tileLocks.forEach(l=>{
    const p = iso(l.x,l.y,camera);
    ctx.fillStyle = 'rgba(120,0,0,0.7)';
    ctx.fillRect(p.x-6, p.y-20, 44, 20);
    const remain = Math.max(0,(l.expires - performance.now())/5000);
    ctx.fillStyle = '#ffb3b3';
    ctx.fillRect(p.x-6, p.y-22, 44*remain, 4);
  });

  // puzzle marker
  if(!puzzle.solved){
    const p = iso(puzzle.x,puzzle.y,camera);
    ctx.fillStyle = '#2c2b17'; ctx.fillRect(p.x-6, p.y-18, 36, 18);
    for(let i=0;i<3;i++){
      ctx.save(); ctx.translate(p.x + (i-1)*18, p.y - 10); ctx.rotate(triangles[i].angle*Math.PI/180);
      ctx.fillStyle = '#f2d86b'; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(-6,8); ctx.lineTo(6,8); ctx.closePath(); ctx.fill(); ctx.restore();
    }
  }

  // draw allies
  allies.forEach(a=>{
    drawPlayerVisual({x:a.x,y:a.y,role:a.role});
  });

  // draw player
  drawPlayerVisual(player);

  // chaser
  drawChaserVisual(chaser);

  // draw HUD controls on top (stick)
  // stick base
  ctx.globalAlpha = 0.45;
  ctx.beginPath(); ctx.arc(stickBase.x, stickBase.y, stickRadius, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.02)'; ctx.fill();
  ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.stroke();
  ctx.globalAlpha = 1;
  // knob
  ctx.beginPath(); ctx.arc(stickBase.x + stickState.dx, stickBase.y + stickState.dy, knobRadius, 0, Math.PI*2);
  ctx.fillStyle = '#fff'; ctx.fill();
  // action ring
  ctx.beginPath(); ctx.arc(actionArea.x, actionArea.y, actionArea.r, 0, Math.PI*2);
  ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 2; ctx.stroke();

  // puzzle overlay if active
  if(puzzle.active){
    ctx.fillStyle = 'rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='18px sans-serif';
    ctx.fillText('パズル：記憶パート（長め）→ 三角整列', W/2, 56);

    const cx = W/2, cy = H/2 - 40;
    // Simon pads
    for(let i=0;i<4;i++){
      const pad = simonPads[i];
      const px = cx + (i-1.5)*120, py = cy;
      roundRect(ctx, px-48, py-48, 96, 96, 16);
      ctx.fillStyle = (currentHighlight===i) ? '#ffffff' : pad.color;
      ctx.fill();
      ctx.fillStyle = '#111'; ctx.font='18px sans-serif'; ctx.fillText(i+1, px, py+6);
    }
    if(simonIndex === -1){
      ctx.fillStyle = '#fff'; ctx.font='16px sans-serif'; ctx.fillText('次：三角形を上向きに合わせてください（タップ）', W/2, cy + 140);
      for(let i=0;i<3;i++){
        ctx.save(); ctx.translate(W/2 + (i-1)*140, cy + 40); ctx.rotate(triangles[i].angle*Math.PI/180);
        ctx.fillStyle = '#f2d86b'; ctx.beginPath(); ctx.moveTo(0,-60); ctx.lineTo(-48,60); ctx.lineTo(48,60); ctx.closePath(); ctx.fill(); ctx.restore();
      }
    } else {
      ctx.fillStyle = '#ccc'; ctx.font='14px sans-serif'; ctx.fillText(`進捗: ${simonPlayerIndex} / ${simonSeq.length}`, W/2, cy + 140);
    }
  }
}

/* rounded rect helper */
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* ======== エンド画面 ======== */
function showEndScreen(win){
  // create overlay
  const ov = document.createElement('div'); ov.style.position='fixed'; ov.style.inset='0'; ov.style.display='flex'; ov.style.alignItems='center'; ov.style.justifyContent='center'; ov.style.zIndex='120';
  ov.style.background='linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.9))';
  ov.innerHTML = `<div style="background:rgba(255,255,255,0.04);padding:18px;border-radius:12px;text-align:center">
    <h2 style="margin:0 0 8px 0">${win?'勝利！パズルを全部クリアしました！':'敗北…捕まってしまいました'}</h2>
    <div style="margin:8px 0 12px 0;color:#ddd">結果を確認したら「タイトルへ戻る」で再スタートできます。</div>
    <div><button id="toTitle">タイトルへ戻る</button></div>
  </div>`;
  document.body.appendChild(ov);
  document.getElementById('toTitle').addEventListener('click', ()=>{
    // remove overlay and restart
    document.body.removeChild(ov);
    restartToTitle();
  });
}

/* Restart to title (reset world state) */
function restartToTitle(){
  // reset vars
  player.x=3; player.y=3; player.role = null;
  allies = [{id:1,role:null,x:4,y:5, speed:0.11, ai:true},{id:2,role:null,x:5,y:4, speed:0.11,ai:true}];
  chaser = {x:26,y:26,speed:0.07,lockUsed:false};
  puzzle.solved=false; puzzle.active=false; simonSeq=[]; simonIndex=0; simonPlayerIndex=0;
  triangles.forEach(t=>t.angle = Math.floor(Math.random()*4)*90);
  tileLocks = []; generateObstacles();
  // show start UI
  startUI.style.display = 'flex';
  document.getElementById('status').textContent = '準備中';
}

/* ======== ゲーム開始 ======== */
function setupAllies(selectedRole){
  // set player role and allies
  player.role = selectedRole;
  player.speed = roles[selectedRole].speed;
  // allies roles: choose other two
  const order = ['sprinter','hacker','trickster'].filter(r=>r!==selectedRole);
  allies.forEach((a,i)=>{ a.role = order[i%order.length]; a.speed = roles[a.role].speed; });
  // position reset
  player.x=3; player.y=3; allies[0].x=4; allies[0].y=3; allies[1].x=3; allies[1].y=4;
  generateObstacles();
  // start main loop
  last = performance.now();
  requestAnimationFrame(updateLoop);
}

/* Start button wired earlier: attach to starting behavior */
document.getElementById('startBtn').addEventListener('click', ()=>{
  // we already initAudio and hide UI in earlier binding: ensure we have role selection
  const sel = selectedRoleGlobal || 'sprinter';
  initAudio(); startUI.style.display='none'; document.getElementById('status').textContent='ゲーム中';
  setupAllies(sel);
});

/* To integrate role selection: we track selectedRoleGlobal */
let selectedRoleGlobal = 'sprinter';
function bindRoleSelectors(){
  document.getElementById('role-sprinter').addEventListener('click', ()=> {selectedRoleGlobal='sprinter'; selectRoleUI('sprinter');});
  document.getElementById('role-hacker').addEventListener('click', ()=> {selectedRoleGlobal='hacker'; selectRoleUI('hacker');});
  document.getElementById('role-trick').addEventListener('click', ()=> {selectedRoleGlobal='trickster'; selectRoleUI('trickster');});
}
function selectRoleUI(key){
  document.querySelectorAll('.role').forEach(e=>e.classList.remove('selected'));
  if(key==='sprinter') document.getElementById('role-sprinter').classList.add('selected');
  if(key==='hacker') document.getElementById('role-hacker').classList.add('selected');
  if(key==='trickster') document.getElementById('role-trick').classList.add('selected');
}
bindRoleSelectors();

/* Also wire start button to init audio + set chosen role before starting */
document.getElementById('startBtn').addEventListener('click', ()=>{
  // Ensure audio context started
  initAudio();
  // set player role from selectedRoleGlobal
  setupAllies(selectedRoleGlobal);
  document.getElementById('status').textContent = 'ゲーム中';
  startUI.style.display = 'none';
});

/* Initialize triangles randomized */
triangles.forEach(t=> t.angle = Math.floor(Math.random()*4)*90);

/* Kick off with initial render loop (idle) */
function idleRender(){
  // render background minimal while on title screen
  ctx.fillStyle = '#0b0b10'; ctx.fillRect(0,0,W,H);
  requestAnimationFrame(idleRender);
}
requestAnimationFrame(idleRender);

</script>
</body>
</html>