<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>å»ƒæ´‹é¤¨ãƒã‚§ã‚¤ã‚¹ v1.2</title>
<style>
:root { --bg:#06060a; --accent:#ffd166; }
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; background: var(--bg); color: #eee; font-family: system-ui, sans-serif; user-select: none; -webkit-user-select: none; overflow: hidden; }
canvas { display: block; width: 100%; height: 100%; touch-action: none; }

/* UI */
#portraitOverlay { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: #000; color: #fff; font-size: 18px; z-index: 500; font-weight: bold; }
#startScreen { position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; background: linear-gradient(180deg, rgba(0,0,0,0.8), rgba(0,0,0,0.95)); z-index: 400; overflow-y: auto; }
.panel { width: 92%; max-width: 600px; background: rgba(255,255,255,0.05); padding: 24px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.1); }
h1 { margin: 0 0 12px 0; text-align: center; color: var(--accent); font-size: 24px; }
.section-title { font-size: 14px; color: #aaa; margin: 16px 0 8px 0; border-bottom: 1px solid #333; padding-bottom: 4px; }

.btn-group { display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap; }
.btn { flex: 1; padding: 10px; border-radius: 6px; border: 1px solid #444; background: #111; color: #fff; cursor: pointer; text-align: center; font-size: 14px; min-width: 30%; }
.btn.selected { border-color: var(--accent); background: rgba(255, 209, 102, 0.1); box-shadow: 0 0 0 2px rgba(255,209,102,0.3); font-weight: bold; }
.btn small { display: block; font-size: 11px; color: #888; margin-top: 4px; font-weight: normal; }

.start-btn { width: 100%; padding: 14px; border-radius: 8px; border: none; background: var(--accent); color: #000; font-weight: bold; font-size: 16px; cursor: pointer; margin-top: 20px; }
.start-btn:active { opacity: 0.8; }

/* HUD */
#hud { position: fixed; inset: 0; pointer-events: none; z-index: 200; display: none; }
#stickBase { position: absolute; left: 24px; bottom: 24px; width: 120px; height: 120px; border-radius: 50%; background: rgba(255,255,255,0.1); pointer-events: auto; display: flex; align-items: center; justify-content: center; border: 2px solid rgba(255,255,255,0.2); }
#stickKnob { width: 50px; height: 50px; border-radius: 50%; background: rgba(255,255,255,0.8); }
#actionBtn { position: absolute; right: 24px; bottom: 24px; width: 90px; height: 90px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); display: flex; align-items: center; justify-content: center; font-weight: bold; pointer-events: auto; cursor: pointer; color: #fff; font-size: 18px; }
#actionBtn:active { background: rgba(255,255,255,0.3); }

#topBar { position: absolute; top: 16px; left: 16px; right: 16px; display: flex; justify-content: space-between; font-size: 16px; font-weight: bold; text-shadow: 1px 1px 2px #000; }
.bar-item { background: rgba(0,0,0,0.5); padding: 6px 12px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.1); }

#resultScreen { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0,0,0,0.85); z-index: 300; flex-direction: column; text-align: center; }
#resultTitle { font-size: 32px; margin-bottom: 24px; font-weight: bold; }
</style>
</head>
<body>

<div id="portraitOverlay">æ¨ªç”»é¢ã§ãƒ—ãƒ¬ã‚¤ã—ã¦ãã ã•ã„</div>

<div id="startScreen">
  <div class="panel">
    <h1>å»ƒæ´‹é¤¨ãƒã‚§ã‚¤ã‚¹ v1.2</h1>
    
    <div class="section-title">é™£å–¶é¸æŠ</div>
    <div class="btn-group" id="factionGroup">
      <div class="btn selected" data-val="runner">é€ƒèµ°è€…<br><small>ãƒ‘ã‚ºãƒ«ã‚’è§£ã„ã¦é€ƒã’åˆ‡ã‚Œ</small></div>
      <div class="btn" data-val="chaser">è¿½è·¡è€…<br><small>5åˆ†ä»¥å†…ã«3äººæ•ã¾ãˆã‚</small></div>
    </div>

    <div class="section-title">ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼é¸æŠ</div>
    <div class="btn-group" id="charGroup"></div>

    <div class="section-title">é›£æ˜“åº¦ (éƒ¨å±‹æ•° / æš—ã•)</div>
    <div class="btn-group" id="diffGroup">
      <div class="btn" data-val="easy">Easy<br><small>5éƒ¨å±‹</small></div>
      <div class="btn selected" data-val="normal">Normal<br><small>7éƒ¨å±‹</small></div>
      <div class="btn" data-val="hard">Hard<br><small>10éƒ¨å±‹ / æš—é—‡+</small></div>
    </div>

    <button class="start-btn" id="startBtn">ã‚²ãƒ¼ãƒ é–‹å§‹ (ã‚¿ãƒƒãƒ—ã§éŸ³å£°ON)</button>
  </div>
</div>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div id="stickBase"><div id="stickKnob"></div></div>
  <div id="actionBtn">ACT</div>
  <div id="topBar">
    <div class="bar-item">â³ <span id="timeUI">05:00</span></div>
    <div class="bar-item">ğŸ§© æ®‹ã‚Š: <span id="puzzleUI">0</span></div>
    <div class="bar-item">ğŸ‘¥ ç”Ÿå­˜: <span id="aliveUI">3</span>/3</div>
  </div>
</div>

<div id="resultScreen">
  <div id="resultTitle"></div>
  <button class="start-btn" style="width:200px" onclick="location.reload()">ã‚¿ã‚¤ãƒˆãƒ«ã¸æˆ»ã‚‹</button>
</div>

<script>
/**
 * å»ƒæ´‹é¤¨ãƒã‚§ã‚¤ã‚¹ v1.2 - å®Œå…¨ä¿®æ­£ç‰ˆ
 * ä»•æ§˜æ›¸ v1.1 ã«å®Œå…¨æº–æ‹ ãƒ»å…¨ãƒã‚°ä¿®æ­£ãƒ»æ–°è¦ç´ å®Ÿè£…æ¸ˆã¿
 */

const CHARS = {
  runner: [
    { id: 'explorer', name: 'æ¢ç´¢è€…', desc: 'é’ã‚³ãƒ¼ãƒˆ/ãƒ‘ã‚ºãƒ«é€Ÿåº¦+ãƒ»ãƒ©ã‚¤ãƒˆå¼·åŠ›', color: '#3498db', speed: 1.0, puzzleSpeed: 1.2, lightRadius: 420, batteryDrain: 0.7 },
    { id: 'agile', name: 'æ•æ·è€…', desc: 'èµ¤ã‚¹ã‚«ãƒ¼ãƒ•/ç§»å‹•é€Ÿåº¦+', color: '#e74c3c', speed: 1.15, puzzleSpeed: 1.0, lightRadius: 350, batteryDrain: 1.0 },
    { id: 'protector', name: 'ä¿è­·è€…', desc: 'ç™½ãƒãƒ³ãƒˆ/1å›æ•ç²ç„¡åŠ¹', color: '#ecf0f1', speed: 1.0, puzzleSpeed: 1.0, lightRadius: 350, batteryDrain: 1.0, shield: 1 }
  ],
  chaser: [
    { id: 'hunter', name: 'ç´…è¡£ã®ç‹©äºº', desc: 'é«˜é€Ÿè¿½è·¡', color: '#c0392b', speed: 1.1, sight: 1.0 },
    { id: 'watcher', name: 'æ·±æ·µã®ç›£è¦–è€…', desc: 'ç´¢æ•µç¯„å›²+', color: '#2c3e50', speed: 0.95, sight: 1.5 },
    { id: 'ruler', name: 'é–ç¸›ã®çµ±æ²»è€…', desc: 'ãƒ‰ã‚¢ãƒ­ãƒƒã‚¯ä½¿ç”¨', color: '#8e44ad', speed: 1.0, sight: 1.0, hasLock: true }
  ]
};

const TILE_SIZE = 32;
let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let cw = canvas.width = window.innerWidth;
let ch = canvas.height = window.innerHeight;

let gameState = {
  running: false,
  faction: 'runner',
  charId: 'explorer',
  difficulty: 'normal',
  timeLeft: 5 * 60 * 1000,
  darknessAlpha: 0.55,
  doorLockTime: 0
};

let input = { vx: 0, vy: 0, act: false };
let map = null;
let actors = [];
let puzzles = [];
let camera = { x: 0, y: 0 };
let myPlayer = null;

/* =========================================
   UI ã‚¤ãƒ™ãƒ³ãƒˆ
========================================= */
function setupUISelection(groupId, stateKey, onChange) {
  const group = document.getElementById(groupId);
  group.addEventListener('click', (e) => {
    const btn = e.target.closest('.btn');
    if (!btn) return;
    group.querySelectorAll('.btn').forEach(b => b.classList.remove('selected'));
    btn.classList.add('selected');
    gameState[stateKey] = btn.dataset.val;
    if (onChange) onChange();
  });
}

function updateCharSelection() {
  const container = document.getElementById('charGroup');
  container.innerHTML = CHARS[gameState.faction].map((c, i) => 
    `<div class="btn ${i===0?'selected':''}" data-val="${c.id}">${c.name}<br><small>${c.desc}</small></div>`
  ).join('');
  gameState.charId = CHARS[gameState.faction][0].id;
}

setupUISelection('factionGroup', 'faction', updateCharSelection);
setupUISelection('diffGroup', 'difficulty');
document.getElementById('charGroup').addEventListener('click', (e) => {
  const btn = e.target.closest('.btn');
  if (!btn) return;
  document.querySelectorAll('#charGroup .btn').forEach(b => b.classList.remove('selected'));
  btn.classList.add('selected');
  gameState.charId = btn.dataset.val;
});

updateCharSelection();

window.addEventListener('resize', () => {
  cw = canvas.width = window.innerWidth;
  ch = canvas.height = window.innerHeight;
  document.getElementById('portraitOverlay').style.display = (cw > ch) ? 'none' : 'flex';
});
document.getElementById('portraitOverlay').style.display = (cw > ch) ? 'none' : 'flex';

/* =========================================
   ã‚ªãƒ¼ãƒ‡ã‚£ã‚ª
========================================= */
const AudioSys = (() => {
  let actx = null;
  let bgOsc = null;
  function init() {
    if (actx) return;
    actx = new (window.AudioContext || window.webkitAudioContext)();
    // ä½éŸ³ãƒ›ãƒ©ãƒ¼BGM
    bgOsc = actx.createOscillator();
    bgOsc.type = 'sawtooth';
    bgOsc.frequency.setValueAtTime(65, actx.currentTime);
    const gain = actx.createGain();
    gain.gain.value = 0.04;
    const filter = actx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 400;
    bgOsc.connect(filter).connect(gain).connect(actx.destination);
    bgOsc.start();
  }
  function playBeep(freq, type, dur, vol=0.1) {
    if (!actx) return;
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    osc.type = type; osc.frequency.value = freq;
    osc.connect(gain); gain.connect(actx.destination);
    gain.gain.setValueAtTime(vol, actx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, actx.currentTime + dur);
    osc.start(); osc.stop(actx.currentTime + dur);
  }
  return {
    init,
    step: () => playBeep(180 + Math.random()*40, 'square', 0.08, 0.025),
    act: () => playBeep(620, 'sine', 0.09, 0.12),
    solve: () => { playBeep(520,'sine',0.15,0.15); setTimeout(()=>playBeep(920,'sine',0.35,0.12), 120); },
    catch: () => playBeep(90, 'sawtooth', 0.9, 0.4),
    light: () => playBeep(920, 'sine', 0.06, 0.08),
    lock: () => { playBeep(140,'sawtooth',0.4,0.25); setTimeout(()=>playBeep(80,'sawtooth',0.6,0.3), 200); }
  };
})();

/* =========================================
   å…¥åŠ›
========================================= */
const stickBase = document.getElementById('stickBase');
const stickKnob = document.getElementById('stickKnob');
let pointerId = null;

stickBase.addEventListener('pointerdown', e => { pointerId = e.pointerId; stickBase.setPointerCapture(pointerId); handleStick(e); });
stickBase.addEventListener('pointermove', e => { if (e.pointerId === pointerId) handleStick(e); });
stickBase.addEventListener('pointerup', () => resetStick());
stickBase.addEventListener('pointercancel', () => resetStick());

function handleStick(e) {
  const rect = stickBase.getBoundingClientRect();
  const cx = rect.left + rect.width / 2, cy = rect.top + rect.height / 2;
  const dx = e.clientX - cx, dy = e.clientY - cy;
  const dist = Math.hypot(dx, dy);
  const max = 38;
  const nx = dist > max ? (dx/dist)*max : dx;
  const ny = dist > max ? (dy/dist)*max : dy;
  stickKnob.style.transform = `translate(${nx}px, ${ny}px)`;
  input.vx = nx / max; input.vy = ny / max;
}
function resetStick() {
  pointerId = null; stickKnob.style.transform = `translate(0,0)`; input.vx = 0; input.vy = 0;
}

const actBtn = document.getElementById('actionBtn');
actBtn.addEventListener('pointerdown', () => { input.act = true; });
actBtn.addEventListener('pointerup', () => { input.act = false; });

/* =========================================
   ãƒãƒƒãƒ—
========================================= */
class MapGen {
  constructor(diff) {
    this.rooms = diff === 'easy' ? 5 : diff === 'normal' ? 7 : 10;
    this.cells = 32;
    this.grid = Array(this.cells).fill(0).map(() => Array(this.cells).fill(1));
    this.roomCenters = [];
    this.generate();
  }
  generate() {
    let cx = 16, cy = 16;
    this.carve(cx, cy);
    this.roomCenters.push({x:cx, y:cy});
    
    for(let i=1; i<this.rooms; i++) {
      const dir = [[0,-3],[0,3],[-3,0],[3,0]][Math.floor(Math.random()*4)];
      cx = Math.max(4, Math.min(this.cells-5, cx + dir[0]));
      cy = Math.max(4, Math.min(this.cells-5, cy + dir[1]));
      this.carve(cx, cy);
      const prev = this.roomCenters[i-1];
      this.carvePath(prev.x, prev.y, cx, cy);
      this.roomCenters.push({x:cx, y:cy});
    }
  }
  carve(x, y) {
    for(let i=-2; i<=2; i++) for(let j=-2; j<=2; j++) {
      if (Math.abs(i) <= 1 || Math.abs(j) <= 1) this.grid[y+j][x+i] = 0;
    }
  }
  carvePath(x1, y1, x2, y2) {
    let x = x1, y = y1;
    while(x !== x2) { this.grid[y][x] = 0; x += Math.sign(x2 - x); }
    while(y !== y2) { this.grid[y][x] = 0; y += Math.sign(y2 - y); }
  }
  isWall(x, y) {
    const gx = Math.floor(x), gy = Math.floor(y);
    if(gx<0 || gy<0 || gx>=this.cells || gy>=this.cells) return true;
    return this.grid[gy][gx] === 1;
  }
}

function toScreen(wx, wy) {
  const sx = (wx - wy) * TILE_SIZE;
  const sy = (wx + wy) * (TILE_SIZE / 2);
  return { x: sx - camera.x + cw/2, y: sy - camera.y + ch/2 };
}

/* =========================================
   ã‚¢ã‚¯ã‚¿ãƒ¼
========================================= */
class Actor {
  constructor(x, y, faction, typeInfo, isPlayer) {
    this.x = x; this.y = y;
    this.faction = faction;
    this.info = typeInfo;
    this.isPlayer = isPlayer;
    
    this.baseSpeed = (faction === 'runner' ? 0.086 : 0.079) * (typeInfo.speed || 1);
    this.puzzleSpeed = typeInfo.puzzleSpeed || 1.0;
    this.lightRadius = typeInfo.lightRadius || 350;
    this.batteryDrain = typeInfo.batteryDrain || 1.0;
    this.sight = typeInfo.sight || 1.0;
    this.hasLock = !!typeInfo.hasLock;
    this.lockUses = this.hasLock ? 1 : 0;
    
    this.state = 'alive';
    this.shield = typeInfo.shield || 0;
    this.facing = 0;
    this.animTimer = 0;
    this.battery = (faction === 'runner') ? 100 : 0;
    this.lightOn = (faction === 'runner');
  }

  update(dt) {
    if (this.state !== 'alive') return;
    
    let moveX = 0, moveY = 0;
    let acting = false;

    // å…¥åŠ› / AI
    if (this.isPlayer) {
      moveX = input.vx;
      moveY = input.vy;
      acting = input.act;
      if (acting) input.act = false;
    } else {
      if (this.faction === 'runner') {
        // è¿½è·¡è€…å›é¿
        const chasers = actors.filter(a => a.faction === 'chaser');
        let closestChaser = null, minD = 999;
        chasers.forEach(c => {
          const d = Math.hypot(c.x - this.x, c.y - this.y);
          if (d < minD) { minD = d; closestChaser = c; }
        });
        if (closestChaser && minD < 6.5) {
          moveX = this.x - closestChaser.x;
          moveY = this.y - closestChaser.y;
        } else {
          // æœ€å¯„ã‚Šæœªè§£æ±ºãƒ‘ã‚ºãƒ«
          let closestP = null, pd = 999;
          puzzles.forEach(p => {
            if (p.progress < 100) {
              const d = Math.hypot(p.x - this.x, p.y - this.y);
              if (d < pd) { pd = d; closestP = p; }
            }
          });
          if (closestP) {
            moveX = closestP.x - this.x;
            moveY = closestP.y - this.y;
            if (pd < 1.3) acting = true;
          }
        }
      } else {
        // è¿½è·¡è€…AI
        let target = null, minDist = 999;
        actors.forEach(a => {
          if (a.faction === 'runner' && a.state === 'alive') {
            const d = Math.hypot(a.x - this.x, a.y - this.y);
            if (d < minDist) { minDist = d; target = a; }
          }
        });
        if (target) {
          moveX = target.x - this.x;
          moveY = target.y - this.y;
        }
        // çµ±æ²»è€…AIã®ãƒ‰ã‚¢ãƒ­ãƒƒã‚¯
        if (this.hasLock && this.lockUses > 0 && Math.random() < 0.0009) {
          gameState.doorLockTime = 5000;
          this.lockUses = 0;
          AudioSys.lock();
        }
      }
    }

    // æ­£è¦åŒ–
    const len = Math.hypot(moveX, moveY);
    if (len > 0) {
      moveX /= len;
      moveY /= len;
    }

    // ç§»å‹•
    if (Math.abs(moveX) > 0.08 || Math.abs(moveY) > 0.08) {
      this.facing = Math.atan2(moveY, moveX);
      let finalSpeed = this.baseSpeed;
      if (this.faction === 'runner' && gameState.doorLockTime > 0) finalSpeed *= 0.58;
      
      const nx = this.x + moveX * finalSpeed * dt;
      const ny = this.y + moveY * finalSpeed * dt;
      
      if (!map.isWall(nx, this.y)) this.x = nx;
      if (!map.isWall(this.x, ny)) this.y = ny;
      
      this.animTimer += dt;
      if (this.animTimer > 9 && this.isPlayer) {
        AudioSys.step();
        this.animTimer = 0;
      }
    }

    // ã‚¢ã‚¯ã‚·ãƒ§ãƒ³
    if (this.faction === 'runner' && acting) {
      let solved = false;
      for (let p of puzzles) {
        if (p.progress < 100 && Math.hypot(this.x - p.x, this.y - p.y) < 1.4) {
          p.progress += 28 * this.puzzleSpeed;
          solved = true;
          if (p.progress >= 100) {
            p.progress = 100;
            AudioSys.solve();
          }
          break;
        }
      }
      if (!solved && this.battery > 0) {
        this.lightOn = !this.lightOn;
        AudioSys.light();
      }
    } else if (this.faction === 'chaser' && this.isPlayer && acting && this.hasLock && this.lockUses > 0) {
      gameState.doorLockTime = 5000;
      this.lockUses = 0;
      AudioSys.lock();
    }

    // ãƒãƒƒãƒ†ãƒªãƒ¼
    if (this.faction === 'runner' && this.lightOn) {
      this.battery -= dt * thisatteryDrain * 0.85;
      if (this.battery <= 0) this.lightOn = false;
    }

    // æ•ç²åˆ¤å®š
    if (this.faction === 'chaser') {
      actors.forEach(r => {
        if (r.faction === 'runner' && r === 'alive') {
          if (Math.hypot(r.x - this.x, r.y - this.y) < 0.85) {
            if (r.shield > 0) {
              r.shield--;
              r.x += Math.cos(this.facing) * 2.4;
              r.y += Math.sin(this.facing) * 2.4;
            } else {
              r.state = 'caught';
              AudioSys.catch();
            }
          }
        }
      });
    }
  }

  draw() {
    if (this.state !== 'alive') return;
    const s = toScreen(this.x, this.y);
    const bounce = (Math.abs(input.vx) > 0.1 || Math.abs(input.vy) > 0.1) ? Math.sin(Date.now()/90) * 2.5 : 0;

    // å½±
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.beginPath();
    ctx.ellipse(s.x, s.y + 6, 15, 6, 0, 0, Math.PI*2);
    ctx.fill();

    // æœ¬ä½“
    ctx.fillStyle = this.info.color;
    ctx.fillRect(s.x - 11, s.y - 26 - bounce, 22, 26);

    if (this.isPlayer) {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(s.x, s.y - 38 - bounce);
      ctx.lineTo(s.x-6, s.y - 46 - bounce);
      ctx.lineTo(s.x+6, s.y - 46 - bounce);
      ctx.fill();
    }

    if (this.shield > 0) {
      ctx.strokeStyle = 'rgba(255,255,255,0.75)';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(s.x, s.y - 14 - bounce, 19, 0, Math.PI*2);
      ctx.stroke();
    }
  }
}

/* =========================================
   ãƒ¡ã‚¤ãƒ³ãƒ«ãƒ¼ãƒ—
========================================= */
let lastTime = 0;

document.getElementById('startBtn').addEventListener('click', () => {
  AudioSys.init();
  document.getElementById('startScreen').style.display = 'none';
  document.getElementById('hud').style.display = 'block';

  gameState.difficulty = document.querySelector('#diffGroup .selected').dataset.val;
  gameState.darknessAlpha = gameState.difficulty === 'hard' ? 0.66 : 0.55;
  gameState.doorLockTime = 0;

  map = new MapGen(gameState.difficulty);
  actors = [];
  puzzles = [];

  const centers = [...map.roomCenters];

  // é€ƒèµ°è€…3äºº
  if (gameState.faction === 'runner') {
    let types = [...CHARS.runner];
    const playerType = types.find(c c.id === gameState.charId) || types[0];
    types = types.filter(c => c.id !== gameState.charId);
    types.sort(() => Math.random() - 0.5);

    actors.push(new Actor(centers[0].x, centers[].y, 'runner',Type, true));
    actors.push(new Actor(centers[1 % centers.length].x, centers[1 % centers.length].y, 'runner', types[0], false));
    actors.push(new Actor(centers[2 % centers.length].x, centers[2 % centers.length].y, 'runner', types[1] || types[0], false));
  } else {
    // AIé€ƒèµ°è€…ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰
    let types = [...CHARS.runner];
    types.sort(() => Math.random() - 0.5);
    for (let i = 0; i < 3; i++) {
      actors.push(new Actor(centers[i % centers.length].x, centers[i % centers.length].y, 'runner', types[i], false));
    }
  }

  // è¿½è·¡è€…
  const chaserType = CHARS.chaser.find(c => c.id === gameState.charId) || CHARS.chaser[0];
  const isPlayerChaser = gameState.faction === 'chaser';
  const cPos = centers[centers.length - 1];
  actors.push(new Actor(cPos.x, cPos.y, 'chaser', chaserType, isPlayerChaser));

  myPlayer = actors.find(a => a.isPlayer);

  // ãƒ‘ã‚ºãƒ«ï¼ˆéƒ¨å±‹æ•°åˆ†ï¼‰
  for (let i = 0; i < map.rooms; i++) {
    const pos = centers[i % centers.length];
    puzzles.push({ x: pos.x + (Math.random() * 1.6 - 0.8), y: pos.y + (Math.random * 1.6 - 0.8), progress: 0 });
  }

  gameState.running = true;
  gameState.timeLeft = 5 * 60 *1000;
  lastTime = performance.now();
  requestAnimationFrame(loop);
});

function loop(now) {
  if (!gameState.running) return;
  const dt = Math.min(now - lastTime, 50) / 16.666;
  lastTime = now;

  gameState.timeLeft -= dt * 16.666;
  gameState.doorLockTime = Math.max(0, gameState.doorLockTime - dt * 16.666);

  actors.forEach(a => a.update(dt));

  // ã‚«ãƒ¡ãƒ©ï¼ˆå®Œå…¨ã«ä¿®æ­£ï¼‰
  const isoX = (myPlayer.x - myPlayer.y) * TILE_SIZE;
  const isoY = (myPlayer.x + myPlayer.y) * (TILE_SIZE / 2);
  camera.x += (isoX - camera.x) * 0.11;
  camera.y += (isoY - camera.y) * 0.11;

  // æç”»
  ctx.fillStyle = '#0a0a0f';
  ctx.fillRect(0, 0, cw, ch);

  // ãƒãƒƒãƒ—
  for (let y = 0; y < map.cells; y++) {
    for (let x = 0; x < map.cells; x++) {
      if (map.grid[y][x] === 0) {
        const s = toScreen(x, y);
        if (s.x < -80 || s.x > cw + 80 || s.y < -80 || s.y > ch + 80) continue;
        ctx.fillStyle = ((x + y) % 2 === 0) ? '#1f2127' : '#1a1c21';
        ctx.beginPath();
        ctx.moveTo(s.x, s.y - TILE_SIZE / 2);
        ctx.lineTo(s.x + TILE_SIZE, s.y);
        ctx.lineTo(s.x, s.y + TILE_SIZE / 2);
        ctx.lineTo(s.x - TILE_SIZE, s.y);
        ctx.fill();
      }
    }
  }

  // ãƒ‘ã‚ºãƒ«
  puzzles.forEach(p => {
    const s = toScreen(p.x, p.y);
    ctx.fillStyle = p.progress >= 100 ? '#27ae60' : '#e67e22';
    ctx.fillRect(s.x - 11, s.y - 16, 22, 22);
    if (p.progress < 100) {
      ctx.fillStyle = '#000';
      ctx.fillRect(s.x - 14, s.y - 26, 28, 6);
      ctx.fillStyle = '#f1c40f';
      ctx.fillRect(s.x - 13.5, s.y - 25, 27 * (p.progress / 100), 4);
    }
  });

  // ã‚­ãƒ£ãƒ©ã‚¯ã‚¿ãƒ¼ï¼ˆYã‚½ãƒ¼ãƒˆï¼‰
  [...actors].sort((a, b) => a.y - b.y).forEach(a => a.draw());

  // æš—é—‡ + è¦–ç•Œ
  ctx.save();
  ctx.fillStyle = `rgba(0,0,0,${gameState.darknessAlpha})`;
  ctx.fillRect(0, 0, cw, ch);

  ctx.globalCompositeOperation = 'destination-out';
  const myS = toScreen(myPlayer.x, myPlayer.y);

  if (myPlayer.faction === 'runner') {
    // åŸºæœ¬è¦–ç•Œ
    let grad = ctx.createRadialGradient(myS.x, myS.y, 18, myS.x, myS.y, 165);
    grad.addColorStop(0, 'rgba(0,0,0,1)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(myS.x, myS.y, 165, 0, Math.PI * 2);
    ctx.fill();

    // æ‡ä¸­é›»ç¯
    if (myPlayer.lightOn) {
      const angle = myPlayer.facing;
      grad = ctx.createRadialGradient(myS.x, myS.y, 0, myS.x, myS.y, myPlayer.lightRadius);
      grad.addColorStop(0, 'rgba(0,0,0,0.92)');
      grad.addColorStop(0.6, 'rgba(0,0,0,0.3)');
      grad.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.moveTo(myS.x, myS.y);
      ctx.arc(myS.x, myS.y, myPlayer.lightRadius, angle - 0.42, angle + 0.42);
      ctx.fill();
    }
  } else {
    // è¿½è·¡è€…è¦–ç•Œ
    const r = 210 * myPlayer.sight;
    let grad = ctx.createRadialGradient(myS.x, myS.y, 30, myS.x, myS.y, r);
    grad.addColorStop(0, 'rgba(0,0,0,1)');
    grad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(myS.x, myS.y, r, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.restore();

  // HUDæ›´æ–°
  const puzzlesLeft = puzzles.filter(p => p.progress < 100).length;
  const aliveCount = actors.filter(a => a.faction === 'runner' && a.state === 'alive').length;

  const m = Math.max(0, Math.floor(gameState.timeLeft / 60000));
  const s = Math.max(0, Math.floor((gameState.timeLeft % 60000) / 1000));
  document.getElementById('timeUI').textContent = `${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  document.getElementById('puzzleUI').textContent = puzzlesLeft;
  document.getElementById('aliveUI').textContent = aliveCount;

  // å‹æ•—
  let result = null;
  if (puzzlesLeft === 0) result = "é€ƒèµ°è€…ã®å‹åˆ©ï¼\nå…¨ãƒ‘ã‚ºãƒ«è§£é™¤";
  else if (aliveCount === 0) result = "è¿½è·¡è€…ã®å‹åˆ©ï¼\né€ƒèµ°è€…å…¨æ»…";
  else if (gameState.timeLeft <= 0) result = "è¿½è·¡è€…ã®å‹åˆ©ï¼\nã‚¿ã‚¤ãƒ ã‚¢ãƒƒãƒ—";

  if (result) {
    gameState.running =;
    document.getElementById('resultTitle').innerHTML = result.replace('\n', '<br>');
    document.getElementById('resultScreen').style.display = 'flex';
    document.getElementById('hud').style.display = 'none';
  } else {
    requestAnimationFrame(loop);
  }
}
</script>
</body>
</html>