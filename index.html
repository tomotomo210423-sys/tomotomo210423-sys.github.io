<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>Mansion Prototype v3</title>
<style>
  html,body{height:100%;margin:0;background:#000;overflow:hidden}
  canvas{display:block}
  #ui {
    position: absolute;
    top: 8px;
    left: 8px;
    color: white;
    font-family: sans-serif;
    z-index: 30;
  }
  button{margin-right:6px}
  #rotateWarning{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:#000;
    color:#fff;
    font-size:20px;
    z-index:50;
  }
  /* 固定アクションボタン見た目（右下） */
  #actionHint{
    position:absolute;
    right:18px;
    bottom:18px;
    width:84px;
    height:84px;
    border-radius:44px;
    background:rgba(255,255,255,0.08);
    display:flex;
    align-items:center;
    justify-content:center;
    color:white;
    font-family:sans-serif;
    z-index:20;
    pointer-events:none; /* 実際はcanvasで判定するので見た目だけ */
  }
</style>
</head>
<body>
  <div id="ui">
    <button onclick="toggleAI()">鬼AI停止</button>
    <button onclick="resetGame()">リセット</button>
    <span id="status">パズルは未解除</span>
  </div>

  <div id="rotateWarning">横画面（ランドスケープ）でプレイしてください</div>
  <div id="actionHint">Action</div>
  <canvas id="game"></canvas>

<script>
/* -------------------------
   基本設定
   ------------------------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W = innerWidth, H = innerHeight;
function resize(){
  W = innerWidth; H = innerHeight;
  canvas.width = W;
  canvas.height = H;
  // スティック基準位置は左下に固定（カメラやウィンドウに合わせて更新）
  stickBase.x = 110;
  stickBase.y = H - 110;
}
window.addEventListener('resize', resize);
resize();

// 横向きチェック
function checkOrientation(){
  const r = document.getElementById('rotateWarning');
  if (window.innerWidth > window.innerHeight) r.style.display = 'none';
  else r.style.display = 'flex';
}
window.addEventListener('resize', checkOrientation);
checkOrientation();

/* -------------------------
   ワールド（グリッド）
   ------------------------- */
const worldSize = 30;      // マス数
const tile = 56;          // タイルサイズ（描画スケール）
const maxX = worldSize - 1;
const maxY = worldSize - 1;

let camera = {x:0, y:0}; // カメラのワールド座標（iso計算で用いる）

// 障害物：整数タイル座標で管理（入れない）
let obstacles = [];
function generateObstacles(){
  obstacles = [];
  const count = 28;
  for(let i=0;i<count;i++){
    // 適度にプレイヤー・パズル・敵から離して配置
    let ox, oy, tries=0;
    do{
      ox = Math.floor(Math.random()*worldSize);
      oy = Math.floor(Math.random()*worldSize);
      tries++;
    } while(((ox<=3 && oy<=3) || (ox>=worldSize-4 && oy>=worldSize-4) || (Math.abs(ox-15)<=1 && Math.abs(oy-15)<=1)) && tries<200);
    // 重複回避
    if(!obstacles.some(o=>o.x===ox && o.y===oy)) obstacles.push({x:ox,y:oy});
  }
}
generateObstacles();

/* -------------------------
   プレイヤー / 追跡者（鬼）
   位置はワールドグリッドをfloatで扱う
   ------------------------- */
let player = { x:3, y:3, speed: 0.12 };
let chaser = { x:26, y:26, speed: 0.07 };
let aiActive = true;

/* -------------------------
   固定スティック（左下）
   可動域リミットあり
   マルチタッチ対応（スティックとActionを別指で可能）
   ------------------------- */
const stickBase = { x:110, y: H-110 }; // 更新はresizeで
const stickRadius = 60; // 可動域
const knobRadius = 30;

let stickState = {
  active:false,
  id:null,      // touch identifier for stick
  dx:0, dy:0    // knob offset
};

// Actionボタン領域（右下の円）
function actionArea(){
  return {
    x: W - 110,
    y: H - 110,
    r: 42
  };
}
let actionState = { active:false, id:null };

/* --------------- タッチ / マウス入力 --------------- */
function touchPointInside(x,y, cx,cy, r){
  const d = Math.hypot(x-cx, y-cy);
  return d <= r;
}

canvas.addEventListener('touchstart', e=>{
  for(const t of e.changedTouches){
    const tx = t.clientX, ty = t.clientY;
    // 優先：左下スティックエリア
    if(touchPointInside(tx,ty,stickBase.x,stickBase.y, stickRadius+20) && !stickState.active){
      stickState.active = true;
      stickState.id = t.identifier;
      stickState.dx = 0; stickState.dy = 0;
    } else {
      // 右下Action
      const a = actionArea();
      if(touchPointInside(tx,ty,a.x,a.y,a.r) && !actionState.active){
        actionState.active = true;
        actionState.id = t.identifier;
        // Action press handled on touchstart (short tap)
        handleActionPress();
      } else {
        // else: ignore (could be map tap)
      }
    }
  }
});

canvas.addEventListener('touchmove', e=>{
  for(const t of e.changedTouches){
    if(stickState.active && t.identifier===stickState.id){
      const dx = t.clientX - stickBase.x;
      const dy = t.clientY - stickBase.y;
      const len = Math.hypot(dx,dy);
      if(len > stickRadius){
        stickState.dx = dx/len * stickRadius;
        stickState.dy = dy/len * stickRadius;
      } else {
        stickState.dx = dx;
        stickState.dy = dy;
      }
    }
  }
});

canvas.addEventListener('touchend', e=>{
  for(const t of e.changedTouches){
    if(stickState.active && t.identifier===stickState.id){
      stickState.active=false; stickState.id=null; stickState.dx=0; stickState.dy=0;
    }
    if(actionState.active && t.identifier===actionState.id){
      actionState.active=false; actionState.id=null;
    }
  }
});

// マウスサポート（デスクトップ確認用）
let mouseDown = false;
canvas.addEventListener('mousedown', e=>{
  const mx=e.clientX, my=e.clientY;
  if(touchPointInside(mx,my,stickBase.x,stickBase.y, stickRadius+20)){
    mouseDown = 'stick';
  } else {
    const a=actionArea();
    if(touchPointInside(mx,my,a.x,a.y,a.r)){
      handleActionPress();
    }
  }
});
canvas.addEventListener('mousemove', e=>{
  if(mouseDown==='stick'){
    const dx=e.clientX-stickBase.x, dy=e.clientY-stickBase.y;
    const len=Math.hypot(dx,dy);
    if(len>stickRadius){
      stickState.dx = dx/len * stickRadius;
      stickState.dy = dy/len * stickRadius;
    } else {
      stickState.dx = dx; stickState.dy = dy;
    }
    stickState.active = true;
  }
});
canvas.addEventListener('mouseup', e=>{
  mouseDown=false; stickState.active=false; stickState.dx=0; stickState.dy=0;
});

/* -------------------------
   パズル（フィールド上）
   - puzzle at tile (15,15)
   - 3 triangles, each has angle property (degrees)
   - playerが近づいてActionボタンで開く
   - 開いたらタップで個別に90度回転
   - 全て上向き(angle %360 == 0)で合格
   ------------------------- */
const puzzle = { x:15, y:15, solved:false, active:false };
let triangles = [
  { angle: Math.floor(Math.random()*4)*90 },
  { angle: Math.floor(Math.random()*4)*90 },
  { angle: Math.floor(Math.random()*4)*90 }
];
const correctAngle = 0; // 上向きを正解

function isPlayerNearPuzzle(){
  const dx = player.x - puzzle.x;
  const dy = player.y - puzzle.y;
  return Math.hypot(dx,dy) < 1.8;
}
function handleActionPress(){
  // 近ければパズルを開く（既に解いていたら何もしない）
  if(!puzzle.solved && isPlayerNearPuzzle()){
    puzzle.active = true;
  }
}

/* -------------------------
   ユーティリティ：タイル占有チェック
   ------------------------- */
function tileBlocked(tx,ty){
  if(tx<0 || ty<0 || tx>maxX || ty>maxY) return true;
  return obstacles.some(o=>o.x===tx && o.y===ty);
}

/* -------------------------
   更新ロジック
   ------------------------- */
function clampPlayerToBounds(px,py){
  // Prevent leaving world and into obstacles (simple step)
  // We'll ensure new position is within [0, maxX] and [0, maxY]
  let nx = Math.max(0, Math.min(maxX, px));
  let ny = Math.max(0, Math.min(maxY, py));
  // If the integer tile is blocked, try to nudge back to previous integer
  const itx = Math.round(nx), ity = Math.round(ny);
  if(tileBlocked(itx,ity)){
    return null; // blocked
  }
  return {x:nx,y:ny};
}

function update(){
  // スティックによる移動（ワールド座標系の簡易）
  if(stickState.active){
    const len = Math.hypot(stickState.dx, stickState.dy);
    if(len > 6){ // デッドゾーン
      const vx = (stickState.dx/ (stickRadius)) * player.speed;
      const vy = (stickState.dy/ (stickRadius)) * player.speed;
      // Note: joystick maps screen dx,dy approx to world x,y movement - good enough for prototype
      const attemptX = player.x + vx;
      const attemptY = player.y + vy;
      const clamped = clampPlayerToBounds(attemptX, attemptY);
      if(clamped) { player.x = clamped.x; player.y = clamped.y; }
    }
  }

  // カメラ追従（iso基準座標）
  camera.x = (player.x - player.y) * tile/2;
  camera.y = (player.x + player.y) * tile/4;
  // カメラの可視範囲をワールドの極値にクランプして背景が見切れないようにする（簡易）
  // compute approximate iso bounding box extents
  const corners = [
    isoToScreen(0,0),
    isoToScreen(worldSize,0),
    isoToScreen(0,worldSize),
    isoToScreen(worldSize,worldSize)
  ];
  let minSX = Math.min(...corners.map(c=>c.x));
  let maxSX = Math.max(...corners.map(c=>c.x));
  let minSY = Math.min(...corners.map(c=>c.y));
  let maxSY = Math.max(...corners.map(c=>c.y));
  // We clamp camera so that world stays roughly in view (this is coarse but helps)
  // target screen center offset is canvas.width/2, canvas.height/3 as used in iso()
  // compute camera X/Y limits so that minSX >= - some margin etc.
  // (simpler approach: do nothing — camera follows player but player constrained to world so outside won't show)
  // We'll skip heavy clamping for now because player cannot exit world.

  // チェイサーAI（単純追跡だが障害物タイルがあれば突入しない）
  if(aiActive && !puzzle.active){
    const dx = player.x - chaser.x;
    const dy = player.y - chaser.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 0.05){
      const stepX = (dx/dist) * chaser.speed;
      const stepY = (dy/dist) * chaser.speed;
      const attemptX = chaser.x + stepX;
      const attemptY = chaser.y + stepY;
      const itx = Math.round(attemptX), ity = Math.round(attemptY);
      if(!tileBlocked(itx,ity)){
        chaser.x = Math.max(0,Math.min(maxX, attemptX));
        chaser.y = Math.max(0,Math.min(maxY, attemptY));
      } else {
        // 障害物に阻まれたら僅かに横に逃がす（単純回避）
        chaser.x += -stepY*0.3;
        chaser.y += stepX*0.3;
        chaser.x = Math.max(0,Math.min(maxX, chaser.x));
        chaser.y = Math.max(0,Math.min(maxY, chaser.y));
      }
    }
  }

  // 捕獲判定
  if(Math.hypot(player.x - chaser.x, player.y - chaser.y) < 0.6){
    document.getElementById('status').innerText = '捕まった！';
  }

  // パズル自動クローズ（離れたら閉じる）
  if(puzzle.active && !isPlayerNearPuzzle()){
    puzzle.active = false;
  }

}

/* -------------------------
   描画（疑似アイソメ変換）
   ------------------------- */
function isoToScreen(x,y){
  // world->screen using camera offset integrated
  const sx = (x - y) * tile/2 - camera.x + W/2;
  const sy = (x + y) * tile/4 - camera.y + H/3;
  return { x: sx, y: sy };
}

function draw(){
  ctx.clearRect(0,0,W,H);

  // 背景タイル（簡易）
  for(let gx=0; gx<worldSize; gx++){
    for(let gy=0; gy<worldSize; gy++){
      const p = isoToScreen(gx,gy);
      // 少し明暗差を付ける
      ctx.fillStyle = ((gx+gy)%2===0) ? '#1e1e1e' : '#151515';
      ctx.fillRect(p.x, p.y, tile/2, tile/4);
    }
  }

  // 障害物（箱）
  obstacles.forEach(o=>{
    const p = isoToScreen(o.x, o.y);
    ctx.fillStyle = '#6b6b6b';
    ctx.fillRect(p.x - 4, p.y - 28, 36, 28);
    // 少し立体感の影
    ctx.fillStyle = 'rgba(0,0,0,0.25)';
    ctx.fillRect(p.x - 4, p.y - 8, 36, 8);
  });

  // パズル（現地表示：三角形3つ並べる）
  if(!puzzle.solved){
    const base = isoToScreen(puzzle.x, puzzle.y);
    // draw base tile marker
    ctx.fillStyle = '#2a2a10';
    ctx.fillRect(base.x, base.y-16, 34, 16);

    // draw three triangles
    for(let i=0;i<3;i++){
      ctx.save();
      ctx.translate(base.x + i*26 - 26, base.y - 22);
      ctx.rotate(triangles[i].angle * Math.PI/180);
      ctx.fillStyle = '#f8d347';
      ctx.beginPath();
      ctx.moveTo(0, -14);
      ctx.lineTo(-12, 12);
      ctx.lineTo(12, 12);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
  }

  // プレイヤー（軽いデザイン）
  const pp = isoToScreen(player.x, player.y);
  // body
  ctx.fillStyle = 'cyan';
  ctx.beginPath();
  ctx.ellipse(pp.x, pp.y-12, 12, 10, 0, 0, Math.PI*2);
  ctx.fill();
  // head
  ctx.fillStyle = '#9ef0ff';
  ctx.beginPath();
  ctx.arc(pp.x, pp.y-22, 6, 0, Math.PI*2);
  ctx.fill();
  // small shadow
  ctx.fillStyle = 'rgba(0,0,0,0.35)';
  ctx.fillRect(pp.x-10, pp.y-6, 20, 6);

  // 追跡者（軽いデザイン）
  const cp = isoToScreen(chaser.x, chaser.y);
  ctx.fillStyle = 'maroon';
  ctx.beginPath();
  ctx.ellipse(cp.x, cp.y-12, 14, 11, 0, 0, Math.PI*2);
  ctx.fill();
  // eye
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.arc(cp.x-4, cp.y-18, 3, 0, Math.PI*2);
  ctx.fill();
  ctx.fillStyle = '#000';
  ctx.beginPath();
  ctx.arc(cp.x-4, cp.y-18, 1.3, 0, Math.PI*2);
  ctx.fill();

  // スティック描画（常に同じ場所）
  // base ring
  ctx.globalAlpha = 0.45;
  ctx.beginPath();
  ctx.arc(stickBase.x, stickBase.y, stickRadius, 0, Math.PI*2);
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fill();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.12)';
  ctx.stroke();
  // inner markers
  ctx.strokeStyle = 'rgba(255,255,255,0.06)';
  for(let i=0;i<8;i++){
    const a = (i/8)*Math.PI*2;
    ctx.beginPath();
    ctx.moveTo(stickBase.x + Math.cos(a)*(stickRadius-6), stickBase.y + Math.sin(a)*(stickRadius-6));
    ctx.lineTo(stickBase.x + Math.cos(a)*(stickRadius-2), stickBase.y + Math.sin(a)*(stickRadius-2));
    ctx.stroke();
  }
  // knob
  ctx.beginPath();
  ctx.globalAlpha = 1;
  ctx.arc(stickBase.x + stickState.dx, stickBase.y + stickState.dy, knobRadius, 0, Math.PI*2);
  ctx.fillStyle = '#fff';
  ctx.fill();
  ctx.globalAlpha = 1;

  // Actionボタン（視覚上はdivで表示しているがcanvasでもわかるように輪郭を追加）
  const a = actionArea();
  ctx.beginPath();
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(255,255,255,0.08)';
  ctx.arc(a.x, a.y, a.r, 0, Math.PI*2);
  ctx.stroke();

  // Puzzle overlay（アクティブ時）
  if(puzzle.active){
    // 半透明背景
    ctx.fillStyle = 'rgba(0,0,0,0.7)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '18px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText('三角形をすべて上向きに合わせてください（タップで回転）', W/2, 80);

    // 描く：三角形を中央に並べる
    const cx = W/2;
    const cy = H/2;
    for(let i=0;i<3;i++){
      ctx.save();
      ctx.translate(cx + (i-1)*100, cy);
      ctx.rotate(triangles[i].angle * Math.PI/180);
      ctx.fillStyle = '#f8d347';
      ctx.beginPath();
      ctx.moveTo(0,-50);
      ctx.lineTo(-40,40);
      ctx.lineTo(40,40);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }
    ctx.fillStyle = '#ccc';
    ctx.font = '14px sans-serif';
    ctx.fillText('タップで個別に回転します。揃えたら自動で閉じます。', W/2, cy + 140);
  }
}

/* -------------------------
   パズルオーバーレイのタップ判定
   ------------------------- */
canvas.addEventListener('pointerdown', e=>{
  if(puzzle.active){
    // 画面中央の3つの座標を判定して、それぞれを回転
    const px = e.clientX, py = e.clientY;
    const cx = W/2, cy = H/2;
    for(let i=0;i<3;i++){
      const tx = cx + (i-1)*100, ty = cy;
      if(Math.hypot(px-tx, py-ty) < 60){
        triangles[i].angle = (triangles[i].angle + 90) % 360;
        // check success
        if(triangles.every(t=>((t.angle%360 + 360)%360) === correctAngle)){
          puzzle.solved = true;
          puzzle.active = false;
          document.getElementById('status').innerText = 'パズル解除！';
        }
        break;
      }
    }
  }
});

/* -------------------------
   デバッグボタン
   ------------------------- */
function toggleAI(){
  aiActive = !aiActive;
  document.getElementById('status').innerText = aiActive ? 'AI稼働中' : 'AI停止中';
}
function resetGame(){
  player.x = 3; player.y = 3;
  chaser.x = 26; chaser.y = 26;
  puzzle.solved = false; puzzle.active = false;
  triangles = [
    { angle: Math.floor(Math.random()*4)*90 },
    { angle: Math.floor(Math.random()*4)*90 },
    { angle: Math.floor(Math.random()*4)*90 }
  ];
  generateObstacles();
  document.getElementById('status').innerText = 'リセット済み（パズル未解除）';
}

/* -------------------------
   メインループ
   ------------------------- */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>