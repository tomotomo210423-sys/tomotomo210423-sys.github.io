<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mansion Prototype</title>

<style>
body {
  margin:0;
  overflow:hidden;
  background:#000;
}

canvas {
  display:block;
}

#rotateWarning{
  position:absolute;
  width:100%;
  height:100%;
  background:black;
  color:white;
  display:flex;
  justify-content:center;
  align-items:center;
  font-size:20px;
  z-index:10;
}

#ui{
  position:absolute;
  top:10px;
  left:10px;
  color:white;
  font-family:sans-serif;
}
</style>
</head>
<body>

<div id="rotateWarning">横画面でプレイしてください</div>
<div id="ui">パズル未解除</div>
<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// 横画面チェック
function checkOrientation(){
  if(window.innerWidth > window.innerHeight){
    document.getElementById("rotateWarning").style.display="none";
  } else {
    document.getElementById("rotateWarning").style.display="flex";
  }
}
window.addEventListener("resize", checkOrientation);
checkOrientation();

// === ワールド ===
const worldSize = 20;
const tile = 40;

const obstacles = [];
for(let i=0;i<20;i++){
  obstacles.push({
    x: Math.floor(Math.random()*worldSize),
    y: Math.floor(Math.random()*worldSize)
  });
}

const puzzle = {
  x: 15,
  y: 15,
  solved:false
};

// === プレイヤー ===
const player = {
  x:2,
  y:2,
  speed:0.08,
  size:15
};

// === 鬼 ===
const enemy = {
  x:18,
  y:18,
  speed:0.05,
  size:15
};

// === 仮想スティック ===
let stick = {
  active:false,
  startX:0,
  startY:0,
  dx:0,
  dy:0
};

canvas.addEventListener("touchstart", e=>{
  stick.active=true;
  stick.startX = e.touches[0].clientX;
  stick.startY = e.touches[0].clientY;
});

canvas.addEventListener("touchmove", e=>{
  const x = e.touches[0].clientX;
  const y = e.touches[0].clientY;
  stick.dx = x - stick.startX;
  stick.dy = y - stick.startY;
});

canvas.addEventListener("touchend", ()=>{
  stick.active=false;
  stick.dx=0;
  stick.dy=0;
});

// === 更新 ===
function update(){

  // プレイヤー移動
  if(stick.active){
    const len = Math.hypot(stick.dx, stick.dy);
    if(len>10){
      player.x += (stick.dx/len)*player.speed;
      player.y += (stick.dy/len)*player.speed;
    }
  }

  // 障害物衝突簡易
  obstacles.forEach(o=>{
    if(Math.abs(player.x-o.x)<0.5 && Math.abs(player.y-o.y)<0.5){
      player.x -= 0.1;
      player.y -= 0.1;
    }
  });

  // 鬼追跡
  const dx = player.x - enemy.x;
  const dy = player.y - enemy.y;
  const dist = Math.hypot(dx,dy);
  enemy.x += (dx/dist)*enemy.speed;
  enemy.y += (dy/dist)*enemy.speed;

  // 捕獲判定
  if(dist<0.5){
    document.getElementById("ui").innerText="捕まった！";
  }

  // パズル判定
  if(!puzzle.solved &&
    Math.abs(player.x-puzzle.x)<0.5 &&
    Math.abs(player.y-puzzle.y)<0.5){
      puzzle.solved=true;
      document.getElementById("ui").innerText="パズル解除成功！";
  }
}

// === 描画（疑似アイソメ） ===
function iso(x,y){
  return {
    x:(x-y)*tile/2 + canvas.width/2,
    y:(x+y)*tile/4 + 100
  };
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // タイル描画
  for(let x=0;x<worldSize;x++){
    for(let y=0;y<worldSize;y++){
      const p=iso(x,y);
      ctx.fillStyle="#222";
      ctx.fillRect(p.x,p.y,tile/2,tile/4);
    }
  }

  // 障害物
  obstacles.forEach(o=>{
    const p=iso(o.x,o.y);
    ctx.fillStyle="#555";
    ctx.fillRect(p.x,p.y-20,20,20);
  });

  // パズル
  if(!puzzle.solved){
    const p=iso(puzzle.x,puzzle.y);
    ctx.fillStyle="yellow";
    ctx.fillRect(p.x,p.y-20,20,20);
  }

  // プレイヤー
  const pp=iso(player.x,player.y);
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.arc(pp.x,pp.y-10,10,0,Math.PI*2);
  ctx.fill();

  // 鬼
  const ep=iso(enemy.x,enemy.y);
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(ep.x,ep.y-10,10,0,Math.PI*2);
  ctx.fill();

  // ライト演出
  const g = ctx.createRadialGradient(
    pp.x,pp.y,50,
    pp.x,pp.y,250
  );
  g.addColorStop(0,"rgba(0,0,0,0)");
  g.addColorStop(1,"rgba(0,0,0,0.8)");
  ctx.fillStyle=g;
  ctx.fillRect(0,0,canvas.width,canvas.height);
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>