<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mansion Prototype v2</title>

<style>
body{
  margin:0;
  overflow:hidden;
  background:#000;
}

canvas{
  display:block;
}

#ui{
  position:absolute;
  top:10px;
  left:10px;
  color:white;
  font-family:sans-serif;
}

button{
  margin-right:5px;
}
</style>
</head>
<body>

<div id="ui">
  <button onclick="toggleAI()">鬼AI停止</button>
  <button onclick="resetGame()">リセット</button>
  <span id="status">パズル未解除</span>
</div>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize(){
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener("resize", resize);

// ===== ワールド =====
const worldSize = 30;
const tile = 60;

let camera = {x:0,y:0};

let obstacles=[];
function generateObstacles(){
  obstacles=[];
  for(let i=0;i<25;i++){
    obstacles.push({
      x:Math.random()*worldSize,
      y:Math.random()*worldSize
    });
  }
}
generateObstacles();

// ===== プレイヤー =====
let player={
  x:5,
  y:5,
  speed:0.12
};

// ===== 鬼 =====
let enemy={
  x:20,
  y:20,
  speed:0.07
};

let aiActive=true;

// ===== パズル（三角形向き合わせ） =====
let puzzleActive=false;

let triangles=[
  {angle:Math.random()*360},
  {angle:Math.random()*360},
  {angle:Math.random()*360}
];

const correctAngle=0;

// ===== スティック =====
let stick={
  active:false,
  baseX:0,
  baseY:0,
  dx:0,
  dy:0
};

canvas.addEventListener("touchstart",e=>{
  stick.active=true;
  stick.baseX=e.touches[0].clientX;
  stick.baseY=e.touches[0].clientY;
});

canvas.addEventListener("touchmove",e=>{
  stick.dx=e.touches[0].clientX-stick.baseX;
  stick.dy=e.touches[0].clientY-stick.baseY;
});

canvas.addEventListener("touchend",()=>{
  stick.active=false;
  stick.dx=0;
  stick.dy=0;
});

// ===== ボタン =====
function toggleAI(){
  aiActive=!aiActive;
}

function resetGame(){
  player.x=5;
  player.y=5;
  enemy.x=20;
  enemy.y=20;
  generateObstacles();
  triangles.forEach(t=>t.angle=Math.random()*360);
  document.getElementById("status").innerText="パズル未解除";
}

// ===== アイソメ変換 =====
function iso(x,y){
  return{
    x:(x-y)*tile/2 - camera.x + canvas.width/2,
    y:(x+y)*tile/4 - camera.y + canvas.height/3
  };
}

// ===== 更新 =====
function update(){

  // カメラ追従
  camera.x=(player.x-player.y)*tile/2;
  camera.y=(player.x+player.y)*tile/4;

  // プレイヤー移動
  if(stick.active){
    const len=Math.hypot(stick.dx,stick.dy);
    if(len>15){
      player.x+=(stick.dx/len)*player.speed;
      player.y+=(stick.dy/len)*player.speed;
    }
  }

  // 鬼追跡
  if(aiActive){
    const dx=player.x-enemy.x;
    const dy=player.y-enemy.y;
    const dist=Math.hypot(dx,dy);
    enemy.x+=(dx/dist)*enemy.speed;
    enemy.y+=(dy/dist)*enemy.speed;
  }

  // 捕獲
  if(Math.hypot(player.x-enemy.x,player.y-enemy.y)<0.6){
    document.getElementById("status").innerText="捕まった！";
  }
}

// ===== 三角形パズル描画 =====
function drawPuzzle(){
  ctx.fillStyle="rgba(0,0,0,0.8)";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  triangles.forEach((t,i)=>{
    ctx.save();
    ctx.translate(canvas.width/2-120+120*i,canvas.height/2);
    ctx.rotate(t.angle*Math.PI/180);
    ctx.fillStyle="white";
    ctx.beginPath();
    ctx.moveTo(0,-30);
    ctx.lineTo(-30,30);
    ctx.lineTo(30,30);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  });
}

// タップで回転
canvas.addEventListener("click",e=>{
  if(puzzleActive){
    triangles.forEach(t=>t.angle+=90);

    if(triangles.every(t=>Math.abs(t.angle%360-correctAngle)<1)){
      puzzleActive=false;
      document.getElementById("status").innerText="パズル解除成功！";
    }
  }
});

// ===== 描画 =====
function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);

  // タイル
  for(let x=0;x<worldSize;x++){
    for(let y=0;y<worldSize;y++){
      const p=iso(x,y);
      ctx.fillStyle="#1a1a1a";
      ctx.fillRect(p.x,p.y,tile/2,tile/4);
    }
  }

  // 障害物
  obstacles.forEach(o=>{
    const p=iso(o.x,o.y);
    ctx.fillStyle="#444";
    ctx.fillRect(p.x,p.y-30,30,30);
  });

  // プレイヤー
  let pp=iso(player.x,player.y);
  ctx.fillStyle="cyan";
  ctx.beginPath();
  ctx.arc(pp.x,pp.y-15,15,0,Math.PI*2);
  ctx.fill();

  // 鬼
  let ep=iso(enemy.x,enemy.y);
  ctx.fillStyle="red";
  ctx.beginPath();
  ctx.arc(ep.x,ep.y-15,15,0,Math.PI*2);
  ctx.fill();

  // スティック描画（画像風）
  if(stick.active){
    ctx.globalAlpha=0.4;
    ctx.beginPath();
    ctx.arc(stick.baseX,stick.baseY,60,0,Math.PI*2);
    ctx.strokeStyle="white";
    ctx.lineWidth=4;
    ctx.stroke();

    ctx.beginPath();
    ctx.arc(stick.baseX+stick.dx,stick.baseY+stick.dy,30,0,Math.PI*2);
    ctx.fillStyle="white";
    ctx.fill();
    ctx.globalAlpha=1;
  }

  if(puzzleActive){
    drawPuzzle();
  }
}

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>