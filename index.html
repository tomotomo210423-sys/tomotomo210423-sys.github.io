<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>廃洋館チェイス - 本制作版（修正版）</title>
<style>
  :root{--bg:#08080b;--ui:#eaeaea}
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ui);font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo,sans-serif; -webkit-user-select:none; user-select:none; -webkit-touch-callout:none;}
  canvas{display:block; width:100%; height:100%; touch-action:none; -ms-touch-action:none; background:#0a0a0c;}
  /* Portrait overlay */
  #portraitOverlay{position:fixed;inset:0;background:#000;display:flex;align-items:center;justify-content:center;font-size:20px;z-index:100;color:#fff}
  /* Start UI */
  #startUI{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:90;background:linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0.9))}
  .panel{background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);max-width:92%;width:560px;text-align:center}
  .roles{display:flex;gap:10px;justify-content:center;margin-top:12px}
  .role{flex:1;padding:10px;border-radius:8px;cursor:pointer;border:2px solid rgba(255,255,255,0.04)}
  .role.selected{border-color:#ffd166;background:rgba(255,209,102,0.06)}
  button.startBtn{padding:10px 16px;border-radius:8px;border:none;background:#ffd166;color:#111;font-weight:800;cursor:pointer}
  #hud{position:fixed;left:12px;top:12px;z-index:40}
  #status{font-size:14px;color:#ddd}
  #actionHint{position:fixed;right:18px;bottom:18px;width:86px;height:86px;border-radius:44px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:700;z-index:40;color:#fff;pointer-events:none}
  #hintSmall{position:fixed;left:12px;bottom:12px;font-size:13px;color:#cfcfcf;z-index:40}
</style>
</head>
<body>
  <div id="portraitOverlay">横向き（ランドスケープ）でプレイしてください</div>

  <div id="startUI">
    <div class="panel" role="dialog" aria-modal="true">
      <h2 style="margin:0 0 8px 0">廃洋館チェイス — 開始</h2>
      <p style="margin:0 0 12px 0;color:#ccc">役職を選んで「開始する」を押してください。音声は最初のタップで有効化されます。</p>

      <div class="roles">
        <div class="role" id="role-sprinter" data-role="sprinter">
          <div style="font-weight:800">スプリンター</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">速く移動できる。救助向き。</div>
        </div>
        <div class="role" id="role-hacker" data-role="hacker">
          <div style="font-weight:800">ハッカー</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">パズル処理が速い。</div>
        </div>
        <div class="role" id="role-trick" data-role="trickster">
          <div style="font-weight:800">トリックスター</div>
          <div style="font-size:13px;color:#ddd;margin-top:6px">偽足音で撹乱。</div>
        </div>
      </div>

      <div style="margin-top:14px">
        <button class="startBtn" id="startBtn">開始する</button>
      </div>
      <div style="margin-top:10px;font-size:12px;color:#bbb">サウンド・BGM・少し時間のかかるパズル搭載版</div>
    </div>
  </div>

  <div id="hud"><div id="status">準備中</div></div>
  <div id="actionHint">Action</div>
  <div id="hintSmall">左下スティックで移動／右下でAction</div>

  <canvas id="game"></canvas>

<script>
/* ----------------------
  安定版：注意点
  - pointer イベント＆ touch-action:none
  - resize で全座標更新（スティック／action）
  - start ボタンで AudioContext を生成（モバイル互換）
  - portraitOverlay 表示時は入力を無視
  ---------------------- */

const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d', { alpha: false });

let W = innerWidth, H = innerHeight;
function resize(){
  W = innerWidth; H = innerHeight;
  canvas.width = W; canvas.height = H;
  stickBase.x = 110; stickBase.y = H - 110;
  actionArea.x = W - 110; actionArea.y = H - 110;
  updatePortraitOverlay();
}
window.addEventListener('resize', resize);
resize();

const portraitOverlay = document.getElementById('portraitOverlay');
function updatePortraitOverlay(){
  portraitOverlay.style.display = (W > H) ? 'none' : 'flex';
}
updatePortraitOverlay();

/* ----------------------
  Audio (WebAudio) - start on user action
  ---------------------- */
let audioCtx = null;
let bgmGain = null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  bgmGain = audioCtx.createGain(); bgmGain.gain.value = 0.16; bgmGain.connect(audioCtx.destination);
  startBGM();
}
let bgmTimer = null;
function startBGM(){
  if(!audioCtx) return;
  const base = [440,523.25,659.25,783.99];
  const step = 0.5;
  let t0 = audioCtx.currentTime + 0.05;
  function schedule(){
    for(let i=0;i<base.length;i++){
      const t = t0 + i*step;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type='sine'; o.frequency.value = base[i];
      o.connect(g); g.connect(bgmGain);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.08, t+0.02);
      g.gain.linearRampToValueAtTime(0.0001, t+step-0.02);
      o.start(t); o.stop(t+step);
    }
    t0 += base.length * step;
  }
  schedule();
  bgmTimer = setInterval(schedule, base.length * step * 1000);
}
function playSFX(kind){
  if(!audioCtx) return;
  const now = audioCtx.currentTime;
  if(kind === 'step'){
    const o = audioCtx.createOscillator(); o.type='square'; o.frequency.value = 300 + Math.random()*80;
    const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.05, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
    o.start(now); o.stop(now+0.18);
  } else if(kind === 'open'){
    const o = audioCtx.createOscillator(); o.type='sawtooth'; o.frequency.value = 520;
    const g = audioCtx.createGain(); o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.06, now+0.02); g.gain.linearRampToValueAtTime(0.0001, now+0.36);
    o.start(now); o.stop(now+0.36);
  } else if(kind === 'success'){
    const freqs = [660,880,990];
    freqs.forEach((f,i)=>{ const o=audioCtx.createOscillator(); const g=audioCtx.createGain(); o.type='sine'; o.frequency.value=f; o.connect(g); g.connect(audioCtx.destination);
      g.gain.setValueAtTime(0.0001, now + i*0.02); g.gain.linearRampToValueAtTime(0.08, now + 0.06 + i*0.02); g.gain.exponentialRampToValueAtTime(0.0001, now + 1.0);
      o.start(now + i*0.02); o.stop(now + 1.0);
    });
  } else if(kind === 'fail'){
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='sawtooth'; o.frequency.value=160; o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
    o.start(now); o.stop(now+0.6);
  } else if(kind === 'caught'){
    const o = audioCtx.createOscillator(); const g = audioCtx.createGain(); o.type='square'; o.frequency.value=120; o.connect(g); g.connect(audioCtx.destination);
    g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.18, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+1.2);
    o.start(now); o.stop(now+1.2);
  }
}

/* ----------------------
  World / iso
  ---------------------- */
const worldSize = 30;
const tile = 56;
const maxX = worldSize - 1, maxY = worldSize - 1;
function isoToScreen(x,y,camera){ return { x:(x-y)*tile/2 - camera.x + W/2, y:(x+y)*tile/4 - camera.y + H/3 }; }

/* ----------------------
  Map obstacles
  ---------------------- */
let obstacles = [];
function generateObstacles(){
  obstacles = [];
  const count = 36;
  for(let i=0;i<count;i++){
    let ox,oy,tries=0;
    do{
      ox = Math.floor(Math.random()*worldSize);
      oy = Math.floor(Math.random()*worldSize);
      tries++;
    } while(((ox<=3 && oy<=3) || (ox>=worldSize-4 && oy>=worldSize-4) || (ox===15 && oy===15)) && tries<200);
    if(!obstacles.some(o=>o.x===ox && o.y===oy)) obstacles.push({x:ox,y:oy});
  }
}
generateObstacles();

/* ----------------------
  Roles and characters
  ---------------------- */
const roles = {
  sprinter: {name:'スプリンター', color:'#17dbe6', speed:0.14},
  hacker: {name:'ハッカー', color:'#ffd166', speed:0.10},
  trickster: {name:'トリックスター', color:'#7ad07a', speed:0.11}
};

let selectedRole = 'sprinter';
let player = {x:3,y:3,role:selectedRole,speed:roles[selectedRole].speed};
let allies = [{id:1,role:'hacker',x:4,y:3,speed:roles.hacker.speed},{id:2,role:'trickster',x:3,y:4,speed:roles.trickster.speed}];
let chaser = {x:26,y:26,speed:0.07,lockUsed:false};
let camera = {x:0,y:0};
let tileLocks = []; // {x,y,expires}

/* ======= input: stick & action ======= */
const stickBase = {x:110, y: H - 110};
const stickRadius = 60;
const knobRadius = 28;
let stickState = {active:false, dx:0, dy:0, id:null};

const actionArea = {x: W - 110, y: H - 110, r:42};
let actionState = {active:false, id:null};

function pointerDownHandler(e){
  if(!(W>H)) return; // block in portrait
  if(startUIVisible) return; // block while in start screen
  const px = e.clientX, py = e.clientY;
  // left stick
  if(dist(px,py,stickBase.x,stickBase.y) <= stickRadius + 10 && !stickState.active){
    stickState.active = true; stickState.id = e.pointerId; updateStick(px,py);
  } else if(dist(px,py, actionArea.x, actionArea.y) <= actionArea.r + 10){
    // action
    actionState.active = true; actionState.id = e.pointerId; handleAction();
  } else if(puzzle.active){
    puzzlePointerDown(px,py);
  }
}
function pointerMoveHandler(e){
  if(stickState.active && e.pointerId === stickState.id) updateStick(e.clientX, e.clientY);
}
function pointerUpHandler(e){
  if(stickState.active && e.pointerId === stickState.id){ stickState.active=false; stickState.id=null; stickState.dx=0; stickState.dy=0; }
  if(actionState.active && e.pointerId === actionState.id){ actionState.active=false; actionState.id=null; }
}
canvas.addEventListener('pointerdown', pointerDownHandler);
canvas.addEventListener('pointermove', pointerMoveHandler);
canvas.addEventListener('pointerup', pointerUpHandler);
canvas.addEventListener('pointercancel', pointerUpHandler);

function updateStick(px,py){
  let dx = px - stickBase.x, dy = py - stickBase.y;
  const len = Math.hypot(dx,dy);
  if(len > stickRadius){ dx = dx / len * stickRadius; dy = dy / len * stickRadius; }
  stickState.dx = dx; stickState.dy = dy;
}
function dist(a,b,c,d){ return Math.hypot(a-c,b-d); }

/* ----------------------
  Puzzle: Simon (長め) -> Triangles
  ---------------------- */
const puzzle = {x:15,y:15, solved:false, active:false};
let simonSeq=[], simonIndex=0, simonPlayerIndex=0, currentHighlight=-1;
const SIMON_LENGTH = 7;
const simonPads = [{color:'#ff7a7a'},{color:'#ffd47a'},{color:'#7ad0ff'},{color:'#7affb3'}];
let triangles = [{angle:90},{angle:180},{angle:270}];

function isNearPuzzle(){ return Math.hypot(player.x - puzzle.x, player.y - puzzle.y) < 1.8; }
function startPuzzle(){
  if(puzzle.solved || puzzle.active) return;
  puzzle.active = true; playSFX('open');
  simonSeq=[]; for(let i=0;i<SIMON_LENGTH;i++) simonSeq.push(Math.floor(Math.random()*4));
  simonIndex=0; simonPlayerIndex=0; currentHighlight=-1;
  triangles.forEach(t=> t.angle = Math.floor(Math.random()*4)*90);
  setTimeout(()=> playSimonStep(), 500);
}
function playSimonStep(){
  if(simonIndex >= simonSeq.length){ simonIndex = -1; currentHighlight=-1; playSFX('success'); return; }
  const pad = simonSeq[simonIndex];
  currentHighlight = pad; playSFX('open');
  setTimeout(()=> { currentHighlight = -1; simonIndex++; setTimeout(()=> playSimonStep(), 420); }, 420);
}
function playerPressPad(id){ playSFX('step'); if(simonIndex === -1) return; if(id === simonSeq[simonPlayerIndex]){ simonPlayerIndex++; if(simonPlayerIndex >= simonSeq.length){ simonIndex = -1; simonPlayerIndex=0; playSFX('success'); } } else { playSFX('fail'); simonPlayerIndex=0; setTimeout(()=> playSimonStep(), 600); } }
function puzzlePointerDown(px,py){
  if(simonIndex !== -1){
    const cx = W/2, cy = H/2 - 40;
    for(let i=0;i<4;i++){ const pxi = cx + (i-1.5)*120, pyi = cy; if(dist(px,py,pxi,pyi) < 52){ playerPressPad(i); break; } }
  } else {
    const cx = W/2, cy = H/2 - 40;
    for(let i=0;i<3;i++){ const tx = cx + (i-1)*140, ty = cy + 40; if(dist(px,py,tx,ty) < 70){ triangles[i].angle = (triangles[i].angle + 90) % 360; playSFX('step'); checkTriangles(); break; } }
  }
}
function checkTriangles(){ if(triangles.every(t=> ((t.angle%360+360)%360) === 0)){ puzzle.solved = true; puzzle.active = false; document.getElementById('status').textContent = 'パズル解除！'; playSFX('success'); } }

/* Allies simple AI */
function updateAllies(){
  allies.forEach(a=>{
    if(!puzzle.solved && a.role === 'hacker'){
      const dx = puzzle.x - a.x, dy = puzzle.y - a.y; const d = Math.hypot(dx,dy);
      if(d > 0.6){ a.x += (dx/d) * a.speed * 0.95; a.y += (dy/d) * a.speed * 0.95; }
      if(d < 1.2 && puzzle.active && simonIndex !== -1 && Math.random() < 0.03){ simonIndex = Math.max(0, simonIndex - 1); }
      if(d < 1.2 && simonIndex === -1 && Math.random() < 0.01){ const idx = Math.floor(Math.random()*3); triangles[idx].angle = (triangles[idx].angle + 90) % 360; checkTriangles(); }
    } else {
      const dx = player.x - a.x, dy = player.y - a.y; const d = Math.hypot(dx,dy);
      if(d > 1.5){ a.x += (dx/d) * a.speed * 0.9; a.y += (dy/d) * a.speed * 0.9; }
      else if(Math.random() < 0.01){ a.x += (Math.random()-0.5)*0.2; a.y += (Math.random()-0.5)*0.2; }
    }
    a.x = Math.max(0,Math.min(maxX,a.x)); a.y = Math.max(0,Math.min(maxY,a.y));
  });
}

/* Chaser AI */
function updateChaser(){
  const targets = [player, ...allies];
  let nearest = null, nd = 1e9;
  targets.forEach(t=>{ const d = Math.hypot(t.x - chaser.x, t.y - chaser.y); if(d < nd){ nd = d; nearest = t; }});
  if(nearest){
    const dx = nearest.x - chaser.x, dy = nearest.y - chaser.y; const dist = Math.hypot(dx,dy);
    if(dist > 0.05){
      let nx = chaser.x + (dx/dist) * chaser.speed; let ny = chaser.y + (dy/dist) * chaser.speed;
      const itx = Math.round(nx), ity = Math.round(ny);
      const blocked = obstacles.some(o=>o.x===itx && o.y===ity) || tileLocks.some(l=>l.x===itx && l.y===ity && l.expires > performance.now());
      if(!blocked){ chaser.x = Math.max(0,Math.min(maxX,nx)); chaser.y = Math.max(0,Math.min(maxY,ny)); }
      else { chaser.x += -dy/(dist+0.001) * chaser.speed*0.6; chaser.y += dx/(dist+0.001) * chaser.speed*0.6; }
    }
    if(!chaser.lockUsed && Math.random() < 0.0015){ const lx=Math.round(chaser.x), ly=Math.round(chaser.y); tileLocks.push({x:lx,y:ly,expires:performance.now()+5000}); chaser.lockUsed=true; playSFX('open'); }
  }
  tileLocks = tileLocks.filter(l => l.expires > performance.now());
}

/* isTileBlocked */
function isTileBlocked(tx,ty){ if(tx<0 || ty<0 || tx>maxX || ty>maxY) return true; return obstacles.some(o=>o.x===tx && o.y===ty) || tileLocks.some(l=>l.x===tx && l.y===ty && l.expires > performance.now()); }

/* Action press */
function handleAction(){ if(puzzle.solved) return; if(isNearPuzzle()){ if(!puzzle.active) startPuzzle(); } else { playSFX('open'); } }

/* ======== Rendering visuals ======== */
function drawPlayerVisual(obj){
  const pos = isoToScreen(obj.x, obj.y, camera);
  ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.fillRect(pos.x-12,pos.y-6,24,6);
  const color = roles[obj.role].color;
  ctx.fillStyle = color; ctx.beginPath(); ctx.ellipse(pos.x, pos.y-14, 12,10,0,0,Math.PI*2); ctx.fill();
  // distinctive head/mark per role
  if(obj.role === 'sprinter'){ ctx.fillStyle='#004a59'; ctx.fillRect(pos.x-8,pos.y-26,16,8); ctx.fillStyle='#ffd166'; ctx.beginPath(); ctx.arc(pos.x,pos.y-22,6,0,Math.PI*2); ctx.fill(); }
  else if(obj.role === 'hacker'){ ctx.fillStyle='#111'; ctx.fillRect(pos.x-8,pos.y-26,16,8); ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pos.x,pos.y-22,6,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.fillRect(pos.x-3.5,pos.y-24,2,2); ctx.fillRect(pos.x+1.5,pos.y-24,2,2); }
  else { ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pos.x,pos.y-22,6,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#7a2bff'; ctx.fillRect(pos.x-8,pos.y-24,16,4); }
}
function drawChaserVisual(c){
  const pos = isoToScreen(c.x,c.y,camera);
  ctx.fillStyle='rgba(0,0,0,0.4)'; ctx.fillRect(pos.x-14,pos.y-8,28,8);
  ctx.fillStyle='#6b1f23'; ctx.beginPath(); ctx.ellipse(pos.x,pos.y-12,14,11,0,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pos.x-5,pos.y-18,3.2,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(pos.x-5,pos.y-18,1.3,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(pos.x+3.5,pos.y-17.5,2.7,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(pos.x+3.5,pos.y-17.5,1.0,0,Math.PI*2); ctx.fill();
}

/* draw loop */
function render(){
  ctx.fillStyle='#0b0b10'; ctx.fillRect(0,0,W,H);
  for(let gx=0; gx<worldSize; gx++){
    for(let gy=0; gy<worldSize; gy++){
      const p = isoToScreen(gx,gy,camera);
      ctx.fillStyle = ((gx+gy)%2===0) ? '#141416' : '#101013';
      ctx.fillRect(p.x,p.y,tile/2,tile/4);
    }
  }
  obstacles.forEach(o=>{ const p=isoToScreen(o.x,o.y,camera); ctx.fillStyle='#5c4f3f'; ctx.fillRect(p.x-4,p.y-28,36,28); ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fillRect(p.x-4,p.y-28,36,6);});
  tileLocks.forEach(l=>{ const p=isoToScreen(l.x,l.y,camera); ctx.fillStyle='rgba(120,0,0,0.7)'; ctx.fillRect(p.x-6,p.y-20,44,20); const remain=(l.expires-performance.now())/5000; ctx.fillStyle='#ffb3b3'; ctx.fillRect(p.x-6,p.y-22,44*Math.max(0,remain),4); });
  if(!puzzle.solved){ const p=isoToScreen(puzzle.x,puzzle.y,camera); ctx.fillStyle='#2c2b17'; ctx.fillRect(p.x-6,p.y-18,36,18); for(let i=0;i<3;i++){ ctx.save(); ctx.translate(p.x+(i-1)*18,p.y-10); ctx.rotate(triangles[i].angle*Math.PI/180); ctx.fillStyle='#f2d86b'; ctx.beginPath(); ctx.moveTo(0,-8); ctx.lineTo(-6,8); ctx.lineTo(6,8); ctx.closePath(); ctx.fill(); ctx.restore(); } }
  allies.forEach(a=> drawPlayerVisual(a));
  drawPlayerVisual(player);
  drawChaserVisual(chaser);
  // HUD controls overlay visuals
  ctx.globalAlpha = 0.45; ctx.beginPath(); ctx.arc(stickBase.x, stickBase.y, stickRadius,0,Math.PI*2); ctx.fillStyle='rgba(255,255,255,0.02)'; ctx.fill(); ctx.lineWidth=2; ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.stroke(); ctx.globalAlpha=1;
  ctx.beginPath(); ctx.arc(stickBase.x + stickState.dx, stickBase.y + stickState.dy, knobRadius,0,Math.PI*2); ctx.fillStyle='#fff'; ctx.fill();
  ctx.beginPath(); ctx.arc(actionArea.x, actionArea.y, actionArea.r, 0, Math.PI*2); ctx.strokeStyle='rgba(255,255,255,0.08)'; ctx.lineWidth=2; ctx.stroke();
  if(puzzle.active){
    ctx.fillStyle='rgba(0,0,0,0.75)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle='#fff'; ctx.textAlign='center'; ctx.font='18px sans-serif'; ctx.fillText('パズル：記憶パート（長め）→ 三角整列', W/2, 56);
    const cx=W/2, cy=H/2 - 40;
    for(let i=0;i<4;i++){ const pad = simonPads[i]; const px=cx + (i-1.5)*120, py=cy; roundRect(ctx, px-48, py-48, 96, 96, 16); ctx.fillStyle = (currentHighlight===i) ? '#fff' : pad.color; ctx.fill(); ctx.fillStyle='#111'; ctx.font='18px sans-serif'; ctx.fillText(i+1, px, py+6); }
    if(simonIndex === -1){ ctx.fillStyle='#fff'; ctx.font='16px sans-serif'; ctx.fillText('次：三角形を上向きに合わせてください（タップ）', W/2, cy + 140); for(let i=0;i<3;i++){ ctx.save(); ctx.translate(W/2 + (i-1)*140, cy + 40); ctx.rotate(triangles[i].angle*Math.PI/180); ctx.fillStyle='#f2d86b'; ctx.beginPath(); ctx.moveTo(0,-60); ctx.lineTo(-48,60); ctx.lineTo(48,60); ctx.closePath(); ctx.fill(); ctx.restore(); } } else { ctx.fillStyle='#ccc'; ctx.font='14px sans-serif'; ctx.fillText(`進捗: ${simonPlayerIndex} / ${simonSeq.length}`, W/2, cy + 140); }
  }
  ctx.fillStyle='#ddd'; ctx.textAlign='left'; ctx.font='13px sans-serif'; ctx.fillText(`座標: (${player.x.toFixed(2)}, ${player.y.toFixed(2)})`, 12, H - 24);
}

/* helper roundRect */
function roundRect(ctx,x,y,w,h,r){ ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); }

/* ======== Game loop & update ======== */
let running = false;
let lastTime = performance.now();
function tick(now){
  const dt = (now - lastTime)/1000; lastTime = now;
  // movement
  if(stickState.active){
    const len = Math.hypot(stickState.dx, stickState.dy);
    if(len > 6){
      const vx = (stickState.dx / stickRadius) * player.speed;
      const vy = (stickState.dy / stickRadius) * player.speed;
      const nx = player.x + vx, ny = player.y + vy;
      const itx = Math.round(nx), ity = Math.round(ny);
      if(nx>=0 && ny>=0 && nx<=maxX && ny<=maxY && !isTileBlocked(itx,ity)){ player.x = nx; player.y = ny; playSFX('step'); }
    }
  }
  camera.x = (player.x - player.y) * tile/2; camera.y = (player.x + player.y) * tile/4;
  updateAllies(); updateChaser();
  if(Math.hypot(player.x - chaser.x, player.y - chaser.y) < 0.6){
    document.getElementById('status').textContent = '捕まった！';
    playSFX('caught');
    endGame(false);
    return;
  }
  if(puzzle.active && !isNearPuzzle()) puzzle.active = false;
  render();
  if(running) requestAnimationFrame(tick);
}

/* end game */
function endGame(win){
  running = false;
  // show simple overlay
  const overlay = document.createElement('div'); overlay.style.position='fixed'; overlay.style.inset=0; overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center'; overlay.style.zIndex=200; overlay.style.background='linear-gradient(180deg, rgba(0,0,0,0.6), rgba(0,0,0,0.9))';
  overlay.innerHTML = `<div style="background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;text-align:center;color:#fff">
    <h2 style="margin:0 0 8px 0">${win ? '勝利！' : '敗北…'}</h2>
    <button id="restartBtn" style="padding:8px 12px;border-radius:8px;border:none;background:#ffd166;color:#111;font-weight:800;">タイトルへ戻る</button>
  </div>`;
  document.body.appendChild(overlay);
  document.getElementById('restartBtn').addEventListener('click', ()=>{
    document.body.removeChild(overlay);
    restartToTitle();
  });
}
function restartToTitle(){
  // reset state and show start UI
  player = {x:3,y:3,role:selectedRole,speed:roles[selectedRole].speed};
  allies = [{id:1,role:'hacker',x:4,y:3,speed:roles.hacker.speed},{id:2,role:'trickster',x:3,y:4,speed:roles.trickster.speed}];
  chaser = {x:26,y:26,speed:0.07,lockUsed:false};
  puzzle.solved=false; puzzle.active=false; simonSeq=[]; simonIndex=0; simonPlayerIndex=0;
  tileLocks = []; generateObstacles();
  document.getElementById('status').textContent = '準備中';
  startUIVisible = true; document.getElementById('startUI').style.display = 'flex';
}

/* ======== Start UI wiring ======== */
let startUIVisible = true;
function wireStartUI(){
  // single selection handlers
  document.getElementById('role-sprinter').addEventListener('click', ()=> selectRole('sprinter'));
  document.getElementById('role-hacker').addEventListener('click', ()=> selectRole('hacker'));
  document.getElementById('role-trick').addEventListener('click', ()=> selectRole('trickster'));
  function selectRole(k){
    selectedRole = k;
    document.querySelectorAll('.role').forEach(r=>r.classList.remove('selected'));
    if(k==='sprinter') document.getElementById('role-sprinter').classList.add('selected');
    if(k==='hacker') document.getElementById('role-hacker').classList.add('selected');
    if(k==='trickster') document.getElementById('role-trick').classList.add('selected');
  }
  selectRole(selectedRole); // initial
  document.getElementById('startBtn').addEventListener('click', ()=>{
    // start sequence: init audio, setup roles, hide start UI, start loop
    initAudio();
    player.role = selectedRole; player.speed = roles[selectedRole].speed;
    // assign allies roles
    const other = ['sprinter','hacker','trickster'].filter(r=>r!==selectedRole);
    allies[0].role = other[0]; allies[0].speed = roles[other[0]].speed; allies[1].role = other[1]; allies[1].speed = roles[other[1]].speed;
    document.getElementById('startUI').style.display = 'none'; startUIVisible = false;
    document.getElementById('status').textContent = 'ゲーム中';
    running = true; lastTime = performance.now(); requestAnimationFrame(tick);
  });
}
wireStartUI();

/* helpers for puzzle overlay */
canvas.addEventListener('pointerdown', (e)=>{ if(puzzle.active) puzzlePointerDown(e.clientX, e.clientY); });

/* utility setInterval for rendering while on title will be handled by tick loop only after start */

/* utility: isTileBlocked used above implemented already */

/* kick off initial render for title screen */
(function initialDraw(){
  render();
})();

/* that's it - stable structure */
</script>
</body>
</html>