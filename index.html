<!DOCTYPE html>

<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>3in1 RETRO GAME</title>
<style>
  body { margin: 0; padding: 0; background-color: #111; display: flex; justify-content: center; align-items: center; min-height: 100vh; touch-action: none; font-family: 'Courier New', Courier, monospace; user-select: none; }
  #gameboy { width: 100%; max-width: 400px; height: 100vh; max-height: 850px; background-color: #d8d8d8; border-radius: 20px; display: flex; flex-direction: column; box-shadow: inset -5px -5px 15px rgba(0,0,0,0.2), 5px 5px 20px rgba(0,0,0,0.8); position: relative; overflow: hidden; }
  #screen-container { flex: 1; background-color: #444; margin: 20px 20px 10px 20px; border-radius: 10px 10px 40px 10px; display: flex; justify-content: center; align-items: center; padding: 15px; border: 3px solid #777; box-shadow: inset 2px 2px 10px rgba(0,0,0,0.5); }
  canvas { background-color: #000; width: 100%; max-width: 280px; aspect-ratio: 1 / 1.5; image-rendering: pixelated; box-shadow: 0 0 10px rgba(0,0,0,0.8); }
  #controls { height: 280px; position: relative; background: #d8d8d8; }
  #dpad { position: absolute; left: 30px; top: 50px; width: 120px; height: 120px; }
  .d-btn { position: absolute; background-color: #333; border-radius: 4px; box-shadow: inset -2px -2px 5px rgba(0,0,0,0.5); }
  .d-btn:active { background-color: #111; }
  #btn-up { top: 0; left: 40px; width: 40px; height: 40px; border-radius: 5px 5px 0 0; }
  #btn-down { bottom: 0; left: 40px; width: 40px; height: 40px; border-radius: 0 0 5px 5px; }
  #btn-left { top: 40px; left: 0; width: 40px; height: 40px; border-radius: 5px 0 0 5px; }
  #btn-right { top: 40px; right: 0; width: 40px; height: 40px; border-radius: 0 5px 5px 0; }
  .d-center { top: 40px; left: 40px; width: 40px; height: 40px; background-color: #333; position: absolute; }
  #action-buttons { position: absolute; right: 20px; top: 70px; width: 140px; height: 100px; transform: rotate(-15deg); }
  .a-btn { position: absolute; width: 55px; height: 55px; background-color: #b00; border-radius: 50%; color: #faa; font-weight: bold; font-size: 20px; text-align: center; line-height: 55px; box-shadow: inset -2px -2px 5px rgba(0,0,0,0.5), 3px 3px 6px rgba(0,0,0,0.4); }
  .a-btn:active { background-color: #800; transform: translateY(2px); box-shadow: inset -2px -2px 5px rgba(0,0,0,0.5), 1px 1px 2px rgba(0,0,0,0.4); }
  #btn-b { left: 0; bottom: 0; }
  #btn-a { right: 0; top: 0; }
  .btn-label { position: absolute; font-size: 14px; color: #555; font-weight: bold; }
  #label-b { left: 20px; bottom: -25px; }
  #label-a { right: 20px; top: -25px; }
</style>
</head>
<body>

<div id="gameboy">
  <div id="screen-container">
    <canvas id="gameCanvas" width="200" height="300"></canvas>
  </div>
  <div id="controls">
    <div id="dpad">
      <div class="d-center"></div>
      <div class="d-btn" id="btn-up"></div>
      <div class="d-btn" id="btn-down"></div>
      <div class="d-btn" id="btn-left"></div>
      <div class="d-btn" id="btn-right"></div>
    </div>
    <div id="action-buttons">
      <div class="a-btn" id="btn-b">B</div>
      <div class="btn-label" id="label-b">B</div>
      <div class="a-btn" id="btn-a">A</div>
      <div class="btn-label" id="label-a">A</div>
    </div>
  </div>
</div>

<script>
// --- Audio System ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); if (audioCtx.state === 'suspended') audioCtx.resume(); }

function playSound(type) {
  if (!audioCtx) return;
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain); gain.connect(audioCtx.destination);
  const now = audioCtx.currentTime;
  if (type === 'shoot' || type === 'jump') {
    osc.type = 'square';
    osc.frequency.setValueAtTime(type==='jump'?300:880, now);
    osc.frequency.exponentialRampToValueAtTime(type==='jump'?600:110, now + 0.1);
    gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
    osc.start(now); osc.stop(now + 0.1);
  } else if (type === 'hit' || type === 'damage') {
    osc.type = 'sawtooth';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(20, now + 0.15);
    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.15);
    osc.start(now); osc.stop(now + 0.15);
  } else if (type === 'select') {
    osc.type = 'sine'; osc.frequency.setValueAtTime(880, now);
    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
    osc.start(now); osc.stop(now + 0.05);
  } else if (type === 'attack') {
    osc.type = 'square'; osc.frequency.setValueAtTime(400, now);
    osc.frequency.linearRampToValueAtTime(100, now + 0.1);
    gain.gain.setValueAtTime(0.1, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
    osc.start(now); osc.stop(now + 0.1);
  }
}

// --- Engine & Input ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const keys = { up: false, down: false, left: false, right: false, a: false, b: false };
const keysDown = { up: false, down: false, left: false, right: false, a: false, b: false };
let prevKeys = { ...keys };
let activeApp = null;
let lastTime = 0;

function updateInput() {
  for (let k in keys) {
    keysDown[k] = keys[k] && !prevKeys[k];
    prevKeys[k] = keys[k];
  }
}

// --- Main Menu ---
const MainMenu = {
  cursor: 0,
  apps: ['TETRIVADER', 'UNREASONABLE BROS', 'MICRO QUEST'],
  init() { this.cursor = 0; },
  update() {
    if (keysDown.down) { this.cursor = (this.cursor + 1) % 3; playSound('select'); }
    if (keysDown.up) { this.cursor = (this.cursor + 2) % 3; playSound('select'); }
    if (keysDown.a) { playSound('jump'); activeApp = [Tetrivader, ActionGame, RpgGame][this.cursor]; activeApp.init(); }
  },
  draw() {
    ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 200, 300);
    ctx.fillStyle = '#fff'; ctx.font = '16px monospace'; ctx.fillText('SELECT GAME', 50, 50);
    for (let i=0; i<3; i++) {
      ctx.fillStyle = i === this.cursor ? '#0f0' : '#fff';
      ctx.fillText((i===this.cursor?'> ':'  ') + this.apps[i], 20, 120 + i*40);
    }
    ctx.fillStyle = '#888'; ctx.font = '10px monospace';
    ctx.fillText('CROSS: Select   A: Start', 25, 280);
  }
};

// --- Game 1: TETRIVADER ---
const Tetrivader = {
  board: [], bullets: [], mino: null, score: 0, state: 'play', dropCounter: 0,
  MINOS: [[[1,1,1,1]], [[1,0,0],[1,1,1]], [[0,0,1],[1,1,1]], [[1,1],[1,1]], [[0,1,1],[1,1,0]], [[0,1,0],[1,1,1]], [[1,1,0],[0,1,1]]],
  COLORS: ['#0ff', '#00f', '#f80', '#ff0', '#0f0', '#808', '#f00'],
  init() {
    this.board = Array(15).fill().map(()=>Array(10).fill(0));
    this.px = 4.5; this.cool = 0; this.score = 0; this.bullets = []; this.state = 'play'; this.dropCounter = 0;
    this.spawn();
  },
  spawn() {
    let type = Math.floor(Math.random()*7);
    this.mino = { shape: this.MINOS[type].map(r=>[...r]), x: 4, y: 0, c: this.COLORS[type] };
    if (this.hitTest(this.mino.x, this.mino.y, this.mino.shape)) this.state = 'over';
  },
  hitTest(mx, my, shape) {
    for(let r=0; r<shape.length; r++) {
      for(let c=0; c<shape[0].length; c++) {
        if(shape[r][c]) {
          let nx = mx + c, ny = my + r;
          if(nx<0 || nx>=10 || ny>=15) return true;
          if(ny>=0 && this.board[ny][nx]) return true;
        }
      }
    }
    return false;
  },
  update() {
    if (this.state === 'over') { 
      if(keysDown.a || keysDown.b) { activeApp = MainMenu; MainMenu.init(); } 
      return; 
    }
    
    if (keys.left) this.px = Math.max(0, this.px - 0.15);
    if (keys.right) this.px = Math.min(9, this.px + 0.15);
    if (keysDown.a && this.cool<=0) { 
      this.bullets.push({x:this.px+0.5, y:14}); 
      this.cool=10; 
      playSound('shoot'); 
    }
    if (this.cool>0) this.cool--;
    
    // Bullets
    for (let i = this.bullets.length-1; i>=0; i--) {
      let b = this.bullets[i]; 
      b.y -= 0.6; 
      let h = false;
      let bx = Math.floor(b.x), by = Math.floor(b.y);
      
      if (by>=0 && by<15 && bx>=0 && bx<10 && this.board[by][bx]) { 
        this.board[by][bx]=0; h=true; this.score+=5; playSound('hit'); 
      } else if (this.mino && by>=this.mino.y && by<this.mino.y+this.mino.shape.length && bx>=this.mino.x && bx<this.mino.x+this.mino.shape[0].length) {
        let localY = by - this.mino.y, localX = bx - this.mino.x;
        if (this.mino.shape[localY] && this.mino.shape[localY][localX]) {
          this.mino.shape[localY][localX] = 0; 
          h=true; 
          this.score+=10; 
          playSound('hit');
          
          // Check if mino fully destroyed
          let isEmpty = true;
          for (let r = 0; r < this.mino.shape.length; r++) {
            for (let c = 0; c < this.mino.shape[r].length; c++) {
              if (this.mino.shape[r][c]) isEmpty = false;
            }
          }
          if (isEmpty) { this.score+=50; this.spawn(); }
        }
      }
      if (h || b.y<0) this.bullets.splice(i,1);
    }
    
    // Mino falling
    let dropSpeed = keys.b ? 3 : 1;
    this.dropCounter += dropSpeed;
    if (this.dropCounter >= 20) {
      this.dropCounter = 0;
      if (this.mino) {
        this.mino.y++;
        if (this.hitTest(this.mino.x, this.mino.y, this.mino.shape)) {
          this.mino.y--;
          // Lock mino
          for(let r=0; r<this.mino.shape.length; r++) {
            for(let c=0; c<this.mino.shape[0].length; c++) {
              if(this.mino.shape[r][c] && this.mino.y+r>=0) {
                this.board[this.mino.y+r][this.mino.x+c] = this.mino.c;
              }
            }
          }
          // Line clear
          for(let r=14; r>=0; r--) {
            if(this.board[r].every(v=>v!==0)) { 
              this.board.splice(r,1); 
              this.board.unshift(Array(10).fill(0)); 
              this.score+=100; 
              playSound('select');
              r++; 
            }
          }
          this.spawn();
        }
      }
    }
    
    // Game over check
    let pLeft = Math.floor(this.px);
    let pRight = Math.floor(this.px+0.9);
    if (this.board[14][pLeft] || this.board[14][pRight]) this.state = 'over';
  },
  draw() {
    ctx.fillStyle='#000'; ctx.fillRect(0,0,200,300);
    const drawB = (x,y,c) => { 
      ctx.fillStyle=c; ctx.fillRect(x*20,y*20,20,20); 
      ctx.strokeStyle='#000'; ctx.strokeRect(x*20,y*20,20,20); 
    };
    
    // Board
    for(let r=0; r<15; r++) {
      for(let c=0; c<10; c++) {
        if(this.board[r][c]) drawB(c,r,this.board[r][c]);
      }
    }
    
    // Current mino
    if(this.mino) {
      for(let r=0; r<this.mino.shape.length; r++) {
        for(let c=0; c<this.mino.shape[0].length; c++) {
          if(this.mino.shape[r][c]) drawB(this.mino.x+c, this.mino.y+r, this.mino.c);
        }
      }
    }
    
    // Bullets
    ctx.fillStyle='#ff0'; 
    this.bullets.forEach(b => ctx.fillRect(b.x*20-2, b.y*20-8, 4, 12));
    
    // Player
    ctx.fillStyle='#aaa'; 
    ctx.fillRect(this.px*20, 14*20+10, 20, 10); 
    ctx.fillStyle='#fff';
    ctx.fillRect(this.px*20+8, 14*20, 4, 10);
    
    // Score
    ctx.fillStyle='#fff'; ctx.font='12px monospace'; ctx.fillText('SCORE:'+this.score, 5, 15);
    
    if(this.state==='over') { 
      ctx.fillStyle='rgba(0,0,0,0.8)'; ctx.fillRect(0,100,200,60); 
      ctx.fillStyle='#f00'; ctx.fillText('GAME OVER', 55, 125);
      ctx.fillText('(A/B) Back to Menu', 30, 145);
    }
  }
};

// --- Game 2: UNREASONABLE BROS ---
const ActionGame = {
  stage: 1, state: 'play', map: [], traps: [], p: {x:20, y:200, vx:0, vy:0},
  init() { this.stage = 1; this.loadStage(); },
  loadStage() {
    this.state = 'play'; 
    this.p = {x:20, y:200, vx:0, vy:0}; 
    this.map = []; 
    this.traps = [];
    
    // Generate map
    for(let i=0; i<40; i++) {
      let isHole = (i>5 && i<35 && Math.random()<0.2);
      this.map.push(isHole ? 0 : 1);
      
      // Traps
      if (i>5 && i<35) {
        if (isHole && Math.random()<0.4) {
          this.traps.push({x: i*20-10, y: 180, type: 'hidden', active: false});
        }
        if (!isHole && Math.random()<0.08) {
          this.traps.push({x: i*20, y: 260, type: 'fake'});
        }
        if (!isHole && Math.random()<0.08) {
          this.traps.push({x: i*20+10, y: 0, type: 'spike', vy: 0, active: false});
        }
      }
    }
  },
  update() {
    if (this.state !== 'play') { 
      if(keysDown.a) { 
        if(this.state==='clear') { activeApp=MainMenu; MainMenu.init(); }
        else this.loadStage(); 
      } 
      return; 
    }
    
    // Physics
    if (keys.left) this.p.vx -= 0.5;
    if (keys.right) this.p.vx += 0.5;
    this.p.vx *= 0.8;
    this.p.vy += 0.6;
    
    let nextX = this.p.x + this.p.vx;
    let nextY = this.p.y + this.p.vy;
    let grounded = false;

    // Floor collision
    let gridX = Math.floor(nextX/20);
    if (gridX >= 0 && gridX < this.map.length) {
      if (nextY > 260 && nextY < 280 && this.map[gridX] === 1) { 
        nextY = 260; 
        this.p.vy = 0; 
        grounded = true; 
      }
    }
    
    // Trap logic
    for (let t of this.traps) {
      if (t.type === 'hidden') {
        if (!t.active && nextY < t.y+20 && this.p.y >= t.y+20 && Math.abs(nextX-t.x)<15) { 
          t.active = true; 
          this.p.vy *= -1; 
          playSound('hit'); 
        }
        if (t.active) {
          if (nextY > t.y-20 && nextY < t.y+20 && Math.abs(nextX-t.x)<20) {
            if (this.p.y <= t.y-20) { 
              nextY = t.y-20; 
              this.p.vy=0; 
              grounded=true; 
            } else {
              nextX = this.p.x;
            }
          }
        }
      }
      if (t.type === 'fake') {
        let tx = Math.floor(t.x/20);
        if (tx >= 0 && tx < this.map.length && gridX === tx && nextY===260 && grounded) { 
          this.map[tx]=0; 
          playSound('damage'); 
        }
      }
      if (t.type === 'spike') {
        if (!t.active && Math.abs(nextX - t.x) < 30) t.active = true;
        if (t.active) { 
          t.vy += 0.5; 
          t.y += t.vy; 
          if (Math.abs(nextX - t.x) < 15 && Math.abs(nextY - t.y) < 15) this.die(); 
        }
      }
    }

    if (grounded && keysDown.a) { 
      this.p.vy = -9; 
      playSound('jump'); 
    }
    
    this.p.x = Math.max(0, nextX); 
    this.p.y = nextY;

    if (this.p.y > 320) this.die();
    if (this.p.x > 750) {
      this.stage++; 
      if(this.stage > 3) { 
        this.state = 'clear'; 
        playSound('select'); 
      } else {
        this.loadStage(); 
      }
    }
  },
  die() { 
    this.state = 'dead'; 
    playSound('damage'); 
  },
  draw() {
    ctx.fillStyle = '#6cf'; 
    ctx.fillRect(0,0,200,300);
    
    let camX = Math.max(0, Math.min(600, this.p.x - 100));
    
    // Floor
    ctx.fillStyle = '#c84';
    for(let i=0; i<40; i++) {
      if(this.map[i]===1) ctx.fillRect(i*20 - camX, 280, 20, 20);
    }
    
    // Traps
    for (let t of this.traps) {
      if (t.type === 'hidden' && t.active) { 
        ctx.fillStyle='#a52'; 
        ctx.fillRect(t.x - camX, t.y, 20, 20); 
      }
      if (t.type === 'spike') { 
        ctx.fillStyle='#f00'; 
        ctx.beginPath(); 
        ctx.moveTo(t.x-camX, t.y-10); 
        ctx.lineTo(t.x+20-camX, t.y-10); 
        ctx.lineTo(t.x+10-camX, t.y+20); 
        ctx.fill(); 
      }
    }
    
    // Player
    ctx.fillStyle = this.state==='dead' ? '#f00' : '#00f';
    ctx.fillRect(this.p.x - camX, this.p.y, 16, 16);
    
    // UI
    ctx.fillStyle = '#000'; 
    ctx.font = '14px monospace'; 
    ctx.fillText('STAGE '+this.stage, 5, 20);
    
    if(this.state==='dead') { 
      ctx.fillStyle='rgba(0,0,0,0.8)'; 
      ctx.fillRect(0,100,200,60); 
      ctx.fillStyle='#f00'; 
      ctx.fillText('YOU DIED!', 55, 125);
      ctx.fillText('(A) Retry', 60, 145);
    }
    if(this.state==='clear') { 
      ctx.fillStyle='rgba(0,0,0,0.8)'; 
      ctx.fillRect(0,100,200,60); 
      ctx.fillStyle='#0f0'; 
      ctx.fillText('ALL CLEAR!', 50, 125);
      ctx.fillText('(A) Back to Menu', 30, 145);
    }
  }
};

// --- Game 3: MICRO QUEST ---
const RpgGame = {
  state: 'map',
  p: {x: 4, y: 8, hp: 20, mhp: 20, lv: 1}, 
  enemy: null, 
  msg: '', 
  menuIdx: 0,
  map: [
    [1,1,1,3,1,1,1,1,1,1], 
    [1,0,0,0,0,0,0,1,0,1], 
    [1,0,1,1,1,0,1,1,0,1],
    [1,0,0,0,1,0,0,0,0,1], 
    [1,1,1,0,1,1,1,1,0,1], 
    [1,0,0,0,0,0,0,0,0,1],
    [1,0,1,1,1,1,1,1,0,1], 
    [1,0,0,0,0,0,0,0,0,1], 
    [1,1,1,1,2,1,1,1,1,1],
  ],
  init() { 
    this.p = {x: 4, y: 8, hp: 20, mhp: 20, lv: 1}; 
    this.state = 'map'; 
    this.enemy = null;
    this.showMessage("DEFEAT THE\nDEMON LORD!"); 
  },
  showMessage(text) { 
    this.msg = text; 
    this.state = 'message'; 
    playSound('select'); 
  },
  startBattle(isBoss) {
    this.state = 'battle'; 
    this.menuIdx = 0;
    if (isBoss) {
      this.enemy = { name: 'DEMON LORD', hp: 50, atk: 6, max: 50 };
    } else {
      this.enemy = { name: 'SLIME', hp: 10 + this.p.lv*5, atk: 2 + this.p.lv, max: 10+this.p.lv*5 };
    }
    playSound('damage');
  },
  update() {
    if (this.state === 'message') { 
      if(keysDown.a) { 
        if(this.msg.includes("PEACE")) {
          activeApp=MainMenu; 
          MainMenu.init();
        } else {
          this.state='map';
        }
      } 
      return; 
    }
    
    if (this.state === 'map') {
      let nx = this.p.x, ny = this.p.y;
      if (keysDown.up) ny--; 
      if (keysDown.down) ny++; 
      if (keysDown.left) nx--; 
      if (keysDown.right) nx++;
      
      if (nx!==this.p.x || ny!==this.p.y) {
        if (nx>=0 && nx<10 && ny>=0 && ny<9 && this.map[ny][nx] !== 1) {
          this.p.x = nx; 
          this.p.y = ny;
          playSound('select');
          
          if (this.map[ny][nx] === 3) {
            this.startBattle(true);
          } else if (this.map[ny][nx] === 0 && Math.random() < 0.15) {
            this.startBattle(false);
          }
        }
      }
    }
    
    if (this.state === 'battle') {
      if (keysDown.up || keysDown.down) { 
        this.menuIdx = 1 - this.menuIdx; 
        playSound('select'); 
      }
      if (keysDown.a) {
        if (this.menuIdx === 0) {
          // Attack
          playSound('attack'); 
          let dmg = 5 + this.p.lv*3; 
          this.enemy.hp -= dmg;
          
          if (this.enemy.hp <= 0) {
            if (this.enemy.name === 'DEMON LORD') {
              this.showMessage("DEMON LORD DEFEATED!\nPEACE HAS RETURNED!");
            } else {
              this.p.lv++; 
              this.p.mhp+=5; 
              this.p.hp=this.p.mhp; 
              this.showMessage("YOU WON!\nLEVEL UP! HP RESTORED");
            }
          } else {
            // Enemy counter
            setTimeout(() => {
              this.p.hp -= this.enemy.atk; 
              playSound('damage');
              if (this.p.hp <= 0) { 
                this.p.x=4; 
                this.p.y=8; 
                this.p.hp=this.p.mhp; 
                this.showMessage("YOU DIED...\nBACK TO CASTLE."); 
              }
            }, 300);
          }
        } else {
          // Heal
          playSound('jump'); 
          this.p.hp = Math.min(this.p.mhp, this.p.hp + 10);
          
          // Enemy attacks after healing
          setTimeout(() => {
            this.p.hp -= this.enemy.atk;
            playSound('damage');
            if (this.p.hp <= 0) { 
              this.p.x=4; 
              this.p.y=8; 
              this.p.hp=this.p.mhp; 
              this.showMessage("YOU DIED...\nBACK TO CASTLE."); 
            }
          }, 300);
        }
      }
    }
  },
  draw() {
    ctx.fillStyle = '#000'; 
    ctx.fillRect(0,0,200,300);
    
    if (this.state === 'map' || this.state === 'message') {
      // Draw Map
      for(let r=0; r<9; r++) {
        for(let c=0; c<10; c++) {
          let v = this.map[r][c];
          ctx.fillStyle = v===0 ? '#282' : v===1 ? '#555' : v===2 ? '#00f' : '#f00';
          ctx.fillRect(c*20, r*20+60, 20, 20);
        }
      }
      
      // Draw Player
      ctx.fillStyle = '#ff0'; 
      ctx.fillRect(this.p.x*20+4, this.p.y*20+64, 12, 12);
      
      // Status
      ctx.fillStyle = '#fff'; 
      ctx.font = '12px monospace';
      ctx.fillText(`LV:${this.p.lv}  HP:${this.p.hp}/${this.p.mhp}`, 10, 30);
    }
    
    if (this.state === 'battle') {
      ctx.fillStyle = '#fff'; 
      ctx.font = '14px monospace';
      ctx.fillText(`ENEMY: ${this.enemy.name}`, 20, 50);
      
      // HP Bar
      ctx.fillStyle = '#f00'; 
      ctx.fillRect(20, 60, 160, 10);
      ctx.fillStyle = '#0f0'; 
      ctx.fillRect(20, 60, Math.max(0,160*(this.enemy.hp/this.enemy.max)), 10);
      
      // Enemy sprite
      ctx.fillStyle = this.enemy.name==='DEMON LORD' ? '#800' : '#08f';
      ctx.fillRect(60, 100, 80, 80);
      
      // Battle Menu
      ctx.fillStyle = '#fff';
      ctx.fillText(`HP: ${this.p.hp}/${this.p.mhp}`, 20, 220);
      ctx.fillText((this.menuIdx===0?'> ':'  ')+'FIGHT', 20, 250);
      ctx.fillText((this.menuIdx===1?'> ':'  ')+'HEAL', 100, 250);
    }
    
    if (this.state === 'message') {
      ctx.fillStyle = 'rgba(0,0,0,0.8)'; 
      ctx.fillRect(10, 100, 180, 80);
      ctx.strokeStyle = '#fff'; 
      ctx.strokeRect(10, 100, 180, 80);
      ctx.fillStyle = '#fff'; 
      ctx.font = '12px monospace';
      
      let lines = this.msg.split('\n');
      for(let i=0; i<lines.length; i++) {
        ctx.fillText(lines[i], 20, 130 + i*20);
      }
      ctx.fillText('â–¼ (A)', 150, 170);
    }
  }
};

// --- Main Loop ---
function setupButton(id, keyProp) {
  const el = document.getElementById(id);
  const press = (e) => { e.preventDefault(); keys[keyProp] = true; initAudio(); };
  const release = (e) => { e.preventDefault(); keys[keyProp] = false; };
  el.addEventListener('touchstart', press, {passive: false}); 
  el.addEventListener('touchend', release, {passive: false});
  el.addEventListener('mousedown', press); 
  el.addEventListener('mouseup', release); 
  el.addEventListener('mouseleave', release);
}

setupButton('btn-up', 'up'); 
setupButton('btn-down', 'down'); 
setupButton('btn-left', 'left'); 
setupButton('btn-right', 'right');
setupButton('btn-a', 'a'); 
setupButton('btn-b', 'b');

window.addEventListener('keydown', (e) => {
  if(e.key==='ArrowUp') { keys.up=true; initAudio(); }
  if(e.key==='ArrowDown') { keys.down=true; initAudio(); }
  if(e.key==='ArrowLeft') { keys.left=true; initAudio(); }
  if(e.key==='ArrowRight') { keys.right=true; initAudio(); }
  if(e.key==='z'||e.key===' ') { keys.a=true; initAudio(); }
  if(e.key==='x') { keys.b=true; initAudio(); }
});

window.addEventListener('keyup', (e) => {
  if(e.key==='ArrowUp') keys.up=false;
  if(e.key==='ArrowDown') keys.down=false;
  if(e.key==='ArrowLeft') keys.left=false;
  if(e.key==='ArrowRight') keys.right=false;
  if(e.key==='z'||e.key===' ') keys.a=false;
  if(e.key==='x') keys.b=false;
});

activeApp = MainMenu;
activeApp.init();

function loop(time) {
  updateInput();
  activeApp.update();
  activeApp.draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>

</body>
</html>