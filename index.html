<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<title>廃洋館チェイス - 単一ファイル版（修正版）</title>
<style>
:root{--bg:#06060a;--accent:#ffd166}
*{box-sizing:border-box}
html,body{height:100%;margin:0;background:var(--bg);color:#eee;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN",Meiryo; -webkit-user-select:none; user-select:none;}
canvas{display:block; width:100%; height:100%; touch-action:none;}
/* overlays & UI */
#portraitOverlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:#000;color:#fff;font-size:20px;z-index:200}
#startScreen{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:linear-gradient(180deg,rgba(0,0,0,0.7),rgba(0,0,0,0.9));z-index:190}
.panel{width:92%;max-width:720px;background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;border:1px solid rgba(255,255,255,0.06);text-align:center}
.roles{display:flex;gap:8px;justify-content:center;margin-top:12px}
.roleBtn{flex:1;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:transparent;color:#fff;cursor:pointer}
.roleBtn.selected{border-color:var(--accent);box-shadow:0 0 0 4px rgba(255,209,102,0.06);background:rgba(255,209,102,0.03)}
.startBtn{margin-top:12px;padding:10px 16px;border-radius:8px;border:none;background:var(--accent);color:#111;font-weight:800;cursor:pointer}
.note{font-size:13px;color:#bbb;margin-top:8px}

/* HUD */
#hud{position:fixed;inset:0;pointer-events:none;z-index:170}
#stickBase{position:absolute;left:18px;bottom:18px;width:120px;height:120px;border-radius:60px;background:rgba(255,255,255,0.02);pointer-events:auto;display:flex;align-items:center;justify-content:center}
#stickKnob{width:56px;height:56px;border-radius:28px;background:rgba(255,255,255,0.95);transform:translate(0,0)}
#actionBtn{position:absolute;right:18px;bottom:18px;width:88px;height:88px;border-radius:44px;background:rgba(255,255,255,0.03);display:flex;align-items:center;justify-content:center;font-weight:800;pointer-events:auto;cursor:pointer}
#infoBar{position:absolute;left:12px;top:12px;font-size:14px}
.puzzleOverlay{position:fixed;inset:0;background:rgba(0,0,0,0.85);z-index:300;display:flex;align-items:center;justify-content:center;color:#fff;pointer-events:auto}
.smallBtn{padding:8px 12px;border-radius:8px;border:none;background:var(--accent);color:#111;font-weight:700;cursor:pointer}
</style>
</head>
<body>

<!-- Portrait overlay -->
<div id="portraitOverlay">横画面（ランドスケープ）でプレイしてください</div>

<!-- Start UI -->
<div id="startScreen">
  <div class="panel">
    <h1 style="margin:0 0 6px 0">廃洋館チェイス</h1>
    <p style="margin:0;color:#ddd">役職を選び「開始する」を押してください。最初のタップで音声が有効になります。</p>
    <div class="roles" style="margin-top:12px">
      <button class="roleBtn selected" data-role="sprinter" id="role-sprinter">スプリンター<br><small style="color:#ccc">高速移動</small></button>
      <button class="roleBtn" data-role="hacker" id="role-hacker">ハッカー<br><small style="color:#ccc">パズル得意</small></button>
      <button class="roleBtn" data-role="trickster" id="role-trick">トリックスター<br><small style="color:#ccc">撹乱特化</small></button>
    </div>
    <button class="startBtn" id="startBtn">開始する</button>
    <div class="note">左下スティックで移動、右下Actionでパズル／懐中電灯切替。横画面でプレイしてください。</div>
  </div>
</div>

<!-- Canvas -->
<canvas id="gameCanvas"></canvas>

<!-- HUD -->
<div id="hud">
  <div id="stickBase"><div id="stickKnob"></div></div>
  <div id="actionBtn">ACT</div>
  <div id="infoBar">残り時間: <span id="timeLeft">05:00</span>　パズル残: <span id="pLeft">0</span></div>
</div>

<script>
/* ====================================================
   Single-file final: stable, corrected implementation
   - Corrects earlier issues (undefined Map, mixed coords,
     multiple start handlers, invisible selection, etc.)
   - Uses ISO-like rendering from grid coordinates
   - Audio via WebAudio (initialized on Start)
   - One-file: easy to paste & run
   ==================================================== */

/* -------------------------
   UTILS
   ------------------------- */
function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
function randInt(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }

/* -------------------------
   AUDIO MANAGER (WebAudio)
   must be started on user gesture (Start)
   ------------------------- */
const AudioManager = (function(){
  let ctx = null, bgmGain = null, bgmTimer = null;
  function init(){
    if(ctx) return;
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    bgmGain = ctx.createGain(); bgmGain.gain.value = 0.14; bgmGain.connect(ctx.destination);
    startBgm();
  }
  function startBgm(){
    if(!ctx) return;
    const base = [110,146.83,164.81,220];
    const step = 1.2;
    let t0 = ctx.currentTime + 0.05;
    function schedule(){
      for(let i=0;i<base.length;i++){
        const t = t0 + i*step;
        const o = ctx.createOscillator(); o.type='sine'; o.frequency.value = base[i] * (1 + 0.002*Math.sin(t));
        const g = ctx.createGain(); o.connect(g); g.connect(bgmGain);
        g.gain.setValueAtTime(0.0001,t); g.gain.linearRampToValueAtTime(0.08,t+0.02); g.gain.linearRampToValueAtTime(0.0001,t+step-0.02);
        o.start(t); o.stop(t+step);
      }
      t0 += base.length * step;
    }
    schedule();
    bgmTimer = setInterval(schedule, base.length * step * 1000);
  }
  function playSfx(name){
    if(!ctx) return;
    const now = ctx.currentTime;
    if(name==='step'){
      const o = ctx.createOscillator(); o.type='square'; o.frequency.value = 300 + Math.random()*40;
      const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, now); g.gain.exponentialRampToValueAtTime(0.055, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.18);
      o.start(now); o.stop(now+0.18);
    } else if(name==='open'){
      const o = ctx.createOscillator(); o.type='sawtooth'; o.frequency.value = 520;
      const g = ctx.createGain(); o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.06, now+0.02); g.gain.linearRampToValueAtTime(0.0001, now+0.36);
      o.start(now); o.stop(now+0.36);
    } else if(name==='success'){
      [660,880,990].forEach((f,i)=>{ const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.value=f; o.connect(g); g.connect(ctx.destination);
        g.gain.setValueAtTime(0.0001, now + i*0.02); g.gain.linearRampToValueAtTime(0.08, now + 0.06 + i*0.02); g.gain.exponentialRampToValueAtTime(0.0001, now + 1.0);
        o.start(now + i*0.02); o.stop(now + 1.0);
      });
    } else if(name==='caught'){
      const o = ctx.createOscillator(); const g = ctx.createGain(); o.type='square'; o.frequency.value=110; o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.18, now+0.02); g.gain.exponentialRampToValueAtTime(0.0001, now+1.2);
      o.start(now); o.stop(now+1.2);
    } else if(name==='fail'){
      const o = ctx.createOscillator(); const g = ctx.createGain(); o.type='sawtooth'; o.frequency.value=180; o.connect(g); g.connect(ctx.destination);
      g.gain.setValueAtTime(0.0001, now); g.gain.linearRampToValueAtTime(0.12, now+0.01); g.gain.exponentialRampToValueAtTime(0.0001, now+0.6);
      o.start(now); o.stop(now+0.6);
    }
  }
  return { init, playSfx };
})();

/* -------------------------
   MAP GENERATOR (grid-based)
   world units = grid cells
   tile = 32 px
   ------------------------- */
const TILE = 32;
class MapGen {
  constructor(cells=32, roomCount=7){
    this.cells = cells; // square grid (cells x cells)
    this.roomCount = roomCount;
    this.width = this.cells * TILE;
    this.height = this.cells * TILE;
    this.roomCenters = []; // in grid coords {x:cell, y:cell}
    this.obstacles = []; // {x,y,wCells,hCells}
    this.puzzleCenters = [];
    this.generate();
  }
  generate(){
    // random walk placement on cell grid to make connected rooms
    this.roomCenters = [];
    const gridW = Math.min(8, this.cells-2);
    const gridH = Math.min(8, this.cells-2);
    let cx = Math.floor(gridW/2), cy = Math.floor(gridH/2);
    const used = new Set();
    used.add(cx+','+cy);
    this.roomCenters.push({x:cx+2, y:cy+2}); // offset to avoid edge
    while(this.roomCenters.length < this.roomCount){
      const dir = [[1,0],[-1,0],[0,1],[0,-1]][randInt(0,3)];
      cx += dir[0]; cy += dir[1];
      cx = clamp(cx,0,gridW-1); cy = clamp(cy,0,gridH-1);
      const key = cx+','+cy;
      if(!used.has(key)){
        used.add(key);
        this.roomCenters.push({x: cx+2, y: cy+2});
      }
    }
    // obstacles: scatter boxes in grid coords
    this.obstacles = [];
    for(const rc of this.roomCenters){
      const count = randInt(2,5);
      for(let i=0;i<count;i++){
        const ox = clamp(rc.x + randInt(-2,2), 1, this.cells-2);
        const oy = clamp(rc.y + randInt(-2,2), 1, this.cells-2);
        const w = randInt(1,3), h = randInt(1,3);
        this.obstacles.push({x:ox, y:oy, w:w, h:h});
      }
    }
    // puzzle rooms: pick half of rooms (rounded)
    const pool = [...Array(this.roomCenters.length).keys()];
    pool.sort(()=>Math.random()-0.5);
    const pcount = Math.max(1, Math.floor(this.roomCenters.length * 0.5));
    this.puzzleCenters = pool.slice(0,pcount).map(idx => this.roomCenters[idx]);
  }

  draw(ctx, camera){
    // draw floor tile grid visually (coarse)
    for(let gx=0; gx<this.cells; gx++){
      for(let gy=0; gy<this.cells; gy++){
        const p = isoToScreen(gx, gy, camera);
        // small tile quad (approx)
        ctx.fillStyle = ((gx+gy)%2===0) ? '#141416' : '#101013';
        ctx.fillRect(p.x, p.y, TILE/2 + 0.5, TILE/4 + 0.5);
      }
    }
    // draw obstacles (in pixels)
    for(const o of this.obstacles){
      // draw as box of several cells
      const corners = [
        isoToScreen(o.x - o.w/2, o.y - o.h/2, camera),
        isoToScreen(o.x + o.w/2, o.y + o.h/2, camera)
      ];
      // approximate rect using top-left corner and size (not perfect iso shading but fine)
      ctx.fillStyle = '#5a4f3f';
      const px = corners[0].x, py = corners[0].y;
      const pw = Math.abs(corners[1].x - corners[0].x) + TILE/2;
      const ph = Math.abs(corners[1].y - corners[0].y) + TILE/4;
      ctx.fillRect(px, py - 8, pw, ph + 8);
    }
    // draw puzzle markers
    for(const p of this.puzzleCenters){
      const s = isoToScreen(p.x, p.y, camera);
      ctx.fillStyle = '#2c2b17';
      ctx.fillRect(s.x-16, s.y-16, 32, 16);
      // 3 small triangles
      for(let i=0;i<3;i++){
        ctx.save();
        ctx.translate(s.x + (i-1)*12, s.y - 6);
        ctx.fillStyle = '#f2d86b';
        ctx.beginPath(); ctx.moveTo(0,-6); ctx.lineTo(-4,6); ctx.lineTo(4,6); ctx.closePath(); ctx.fill();
        ctx.restore();
      }
    }
  }

  clampActor(actor){
    actor.x = clamp(actor.x, 1, this.cells - 2);
    actor.y = clamp(actor.y, 1, this.cells - 2);
    // basic obstacle collision pushback
    for(const o of this.obstacles){
      // if actor inside obstacle cell area
      if(actor.x > o.x - o.w/2 - 0.6 && actor.x < o.x + o.w/2 + 0.6 && actor.y > o.y - o.h/2 - 0.6 && actor.y < o.y + o.h/2 + 0.6){
        // push actor out along larger component
        const dx = actor.x - o.x, dy = actor.y - o.y;
        if(Math.abs(dx) > Math.abs(dy)){
          actor.x = (dx > 0) ? o.x + o.w/2 + 0.7 : o.x - o.w/2 - 0.7;
        } else {
          actor.y = (dy > 0) ? o.y + o.h/2 + 0.7 : o.y - o.h/2 - 0.7;
        }
      }
    }
  }
}

/* -------------------------
   ISO transform:
   world coords in grid cells (x,y)
   tile size = TILE px
   camera: pixel offsets precomputed
   returns screen coords in pixels
   ------------------------- */
function isoToScreen(x, y, camera){
  const sx = (x - y) * TILE/2 - camera.x + (canvasW/2);
  const sy = (x + y) * TILE/4 - camera.y + (canvasH/3);
  return { x: sx, y: sy };
}

/* -------------------------
   Actor classes
   ------------------------- */
const ROLE_DEFS = {
  sprinter: { color: '#17dbe6', speed: 0.14 },
  hacker: { color: '#ffd166', speed: 0.10 },
  trickster: { color: '#7ad07a', speed: 0.11 }
};

class Actor {
  constructor(x,y,role='sprinter'){
    this.x = x; this.y = y; this.role = role;
    this.speed = ROLE_DEFS[role].speed;
    this.flashlight = false;
    this.battery = 100;
    this.caught = false;
    this.size = 0.6; // world units (cells)
    this._facingAngle = 0;
  }
  update(input, map, dt){
    if(this.caught) return;
    // input: {vx, vy}
    this.x += (input.vx || 0) * this.speed * dt * 40;
    this.y += (input.vy || 0) * this.speed * dt * 40;
    if((input.vx || input.vy) && (Math.abs(input.vx) + Math.abs(input.vy) > 0.02)){
      this._facingAngle = Math.atan2(input.vy, input.vx);
    }
    if(this.flashlight && this.battery > 0){
      this.battery = Math.max(0, this.battery - 0.02 * dt);
    }
    map.clampActor(this);
  }
  draw(ctx, camera){
    const p = isoToScreen(this.x, this.y, camera);
    // shadow
    ctx.fillStyle = 'rgba(0,0,0,0.35)';
    ctx.fillRect(p.x - 12, p.y - 6, 24, 6);
    // body
    ctx.fillStyle = ROLE_DEFS[this.role].color;
    ctx.beginPath(); ctx.ellipse(p.x, p.y - 14, 12, 10, 0, 0, Math.PI*2); ctx.fill();
    // head mark for role
    ctx.fillStyle = '#fff';
    if(this.role === 'sprinter'){ ctx.fillStyle = '#ffd166'; ctx.fillRect(p.x-6, p.y-24, 12, 6); }
    else if(this.role === 'hacker'){ ctx.fillStyle = '#111'; ctx.fillRect(p.x-8, p.y-26, 16, 6); }
    else { ctx.fillStyle = '#7a2bff'; ctx.fillRect(p.x-8, p.y-24, 16, 4); }
  }
}

class Chaser {
  constructor(x,y){
    this.x = x; this.y = y; this.speed = 0.085; this.lockUsed = false; this.size = 0.8;
    this._onLock = null;
  }
  update(targets, map, dt){
    // pick nearest uncaught
    let nearest = null; let nd = 1e9;
    for(const t of targets){ if(t.caught) continue; const d = Math.hypot(t.x - this.x, t.y - this.y); if(d < nd){ nd = d; nearest = t; } }
    if(!nearest) return;
    const dx = nearest.x - this.x, dy = nearest.y - this.y;
    const dist = Math.hypot(dx,dy);
    if(dist > 0.02){
      this.x += (dx/dist) * this.speed * dt * 40;
      this.y += (dy/dist) * this.speed * dt * 40;
      map.clampActor(this);
    }
    // occasional lock
    if(!this.lockUsed && Math.random() < 0.0009 && nd < 6){
      this.lockUsed = true;
      if(typeof this._onLock === 'function') this._onLock(Math.round(this.x), Math.round(this.y));
    }
  }
  draw(ctx, camera){
    const p = isoToScreen(this.x, this.y, camera);
    ctx.fillStyle = '#6b1f23'; ctx.beginPath(); ctx.ellipse(p.x, p.y-12, 14, 11, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(p.x-5, p.y-18, 3.2, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#000'; ctx.beginPath(); ctx.arc(p.x-5, p.y-18, 1.3, 0, Math.PI*2); ctx.fill();
  }
}

/* -------------------------
   Gear Puzzle (3 gears, coupled)
   ------------------------- */
class GearPuzzle {
  constructor(cellX, cellY){
    this.x = cellX; this.y = cellY;
    this.gears = [ randInt(0,3)*90, randInt(0,3)*90, randInt(0,3)*90 ];
    this.active = false; this.solved = false;
  }
  open(){ if(this.solved) return; this.active = true; AudioManager.playSfx('open'); }
  tap(i){ if(!this.active || this.solved) return; this.gears[i] = (this.gears[i] + 90) % 360;
    if(i===0) this.gears[1] = (this.gears[1] + 90) % 360;
    if(i===1){ this.gears[0] = (this.gears[0] + 90) % 360; this.gears[2] = (this.gears[2] + 90) % 360; }
    if(i===2) this.gears[1] = (this.gears[1] + 90) % 360;
    if(this.gears.every(g => ((g%360)+360)%360 === 0)){ this.solved = true; this.active = false; AudioManager.playSfx('success'); }
  }
  drawOverlay(ctx, W, H){
    // full overlay
    ctx.fillStyle = 'rgba(0,0,0,0.85)'; ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff'; ctx.textAlign='center'; ctx.font='18px sans-serif';
    ctx.fillText('歯車パズル：すべて上向きに揃えてください（タップ）', W/2, 56);
    const cx = W/2, cy = H/2 - 40;
    for(let i=0;i<3;i++){
      ctx.save(); ctx.translate(cx + (i-1)*140, cy); ctx.rotate(this.gears[i] * Math.PI/180);
      ctx.fillStyle = '#f2d86b';
      ctx.beginPath(); ctx.moveTo(0,-60); ctx.lineTo(-48,60); ctx.lineTo(48,60); ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    ctx.fillStyle = '#ccc'; ctx.font='14px sans-serif'; ctx.fillText('タップで回転します', W/2, cy + 170);
  }
}

/* -------------------------
   GLOBAL STATE
   ------------------------- */
let canvas = document.getElementById('gameCanvas');
let ctx = canvas.getContext('2d');
let canvasW = window.innerWidth, canvasH = window.innerHeight;
function resizeCanvas(){ canvasW = canvas.width = window.innerWidth; canvasH = canvas.height = window.innerHeight;
  document.getElementById('portraitOverlay').style.display = (canvasW > canvasH) ? 'none' : 'flex';
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

let difficulty = 'normal';
let roomsByDiff = { easy:5, normal:7, hard:10 };

let map = null;
let player = null;
let allies = [];
let chaser = null;
let puzzles = [];
let tileLocks = [];

let camera = { x:0, y:0 };

let running = false;
let startTime = 0;
let remainingMs = 5*60*1000;

let input = { vx:0, vy:0 };

/* -------------------------
   UI wiring & input
   ------------------------- */
const roleButtons = document.querySelectorAll('.roleBtn');
let selectedRole = 'sprinter';
roleButtons.forEach(btn=>{
  btn.addEventListener('click', ()=>{
    roleButtons.forEach(b=>b.classList.remove('selected'));
    btn.classList.add('selected');
    selectedRole = btn.dataset.role;
  });
});

// stick pointer handling
const stickBase = document.getElementById('stickBase');
const knob = document.getElementById('stickKnob');
let pointerId = null;
stickBase.addEventListener('pointerdown', (e)=>{
  if(document.getElementById('portraitOverlay').style.display !== 'none') return;
  pointerId = e.pointerId;
  stickBase.setPointerCapture(pointerId);
  handleStickMove(e);
});
stickBase.addEventListener('pointermove', (e)=>{
  if(e.pointerId !== pointerId) return;
  handleStickMove(e);
});
stickBase.addEventListener('pointerup', (e)=>{
  if(e.pointerId !== pointerId) return;
  try{ stickBase.releasePointerCapture(pointerId);}catch(e){}
  pointerId = null; knob.style.transform = `translate(0px,0px)`; input.vx = 0; input.vy = 0;
});
function handleStickMove(e){
  const rect = stickBase.getBoundingClientRect();
  const cx = rect.left + rect.width / 2;
  const cy = rect.top + rect.height / 2;
  const dx = e.clientX - cx;
  const dy = e.clientY - cy;
  const max = 36;
  const len = Math.hypot(dx, dy);
  const nx = len > max ? dx/len*max : dx;
  const ny = len > max ? dy/len*max : dy;
  knob.style.transform = `translate(${nx}px, ${ny}px)`;
  input.vx = nx / max;
  input.vy = ny / max;
  // small step sfx for feedback
  if(Math.hypot(input.vx, input.vy) > 0.1) AudioManager.playSfx('step');
}

// Action button
const actionBtn = document.getElementById('actionBtn');
actionBtn.addEventListener('pointerdown', ()=>{
  if(document.getElementById('portraitOverlay').style.display !== 'none') return;
  // If a puzzle is within range and not solved -> open overlay
  for(const p of puzzles){
    if(!p.solved){
      const dist = Math.hypot(player.x - p.x, player.y - p.y);
      if(dist < 2.2){ p.open(); return; }
    }
  }
  // otherwise toggle flashlight
  player.flashlight = !player.flashlight;
  AudioManager.playSfx('open');
});

/* If puzzle overlay active, canvas clicks should rotate gear */
canvas.addEventListener('pointerdown', (e)=>{
  // find active puzzle
  for(const p of puzzles){
    if(p.active && !p.solved){
      // translate click to overlay gear areas
      const mx = e.clientX, my = e.clientY;
      const cx = canvasW/2, cy = canvasH/2 - 40;
      for(let i=0;i<3;i++){
        const gx = cx + (i-1)*140, gy = cy + 40;
        if(Math.hypot(mx-gx, my-gy) < 70){ p.tap(i); document.getElementById('pLeft').textContent = puzzles.filter(pp=>!pp.solved).length; return; }
      }
    }
  }
});

/* -------------------------
   START GAME (single handler)
   ------------------------- */
document.getElementById('startBtn').addEventListener('click', ()=>{
  // Init audio
  AudioManager.init();
  // create map and actors
  const roomCount = roomsByDiff[difficulty] || roomsByDiff.normal;
  map = new MapGen(32, roomCount);
  // spawn player at first room center
  const rc0 = map.roomCenters[0];
  player = new Actor(rc0.x, rc0.y, selectedRole);
  // spawn allies in next centers
  allies = [];
  const otherRoles = ['sprinter','hacker','trickster'].filter(r=> r !== selectedRole);
  for(let i=0;i<2;i++){
    const rc = map.roomCenters[Math.min(i+1, map.roomCenters.length-1)];
    allies.push(new Actor(rc.x + (i*0.4), rc.y - (i*0.2), otherRoles[i]));
  }
  // chaser at last room
  const rcEnd = map.roomCenters[map.roomCenters.length-1];
  chaser = new Chaser(rcEnd.x, rcEnd.y);
  chaser._onLock = (lx, ly)=> tileLocks.push({x:lx, y:ly, expires: performance.now() + 5000});
  // puzzles
  puzzles = map.puzzleCenters.map(p=> new GearPuzzle(p.x, p.y));
  document.getElementById('pLeft').textContent = puzzles.filter(p=>!p.solved).length;
  // hide start screen, start loop
  document.getElementById('startScreen').style.display = 'none';
  running = true; startTime = performance.now(); remainingMs = 5*60*1000;
  lastTick = performance.now(); requestAnimationFrame(loop);
});

/* -------------------------
   GAME LOOP
   ------------------------- */
let lastTick = performance.now();
function loop(ts){
  if(!running) return;
  const dt = Math.max(1, (ts - lastTick)/16.666); lastTick = ts;

  // time update
  const elapsed = ts - startTime;
  remainingMs = Math.max(0, 5*60*1000 - elapsed);
  const mm = Math.floor(remainingMs/60000), ss = Math.floor((remainingMs%60000)/1000);
  document.getElementById('timeLeft').textContent = String(mm).padStart(2,'0') + ':' + String(ss).padStart(2,'0');
  if(remainingMs <= 0){ endGame(false); return; }

  // update actors
  player.update(input, map, dt);
  // simple ally AI: hacker seek nearest puzzle, others follow player
  allies.forEach(a=>{
    if(a.role === 'hacker'){
      const np = puzzles.find(p=>!p.solved);
      if(np){
        const dx = np.x - a.x, dy = np.y - a.y, d = Math.hypot(dx,dy);
        if(d > 1.1){ a.update({vx: dx/d * 0.2, vy: dy/d * 0.2}, map, dt); }
        else {
          // assist occasionally
          if(np.active && Math.random() < 0.02){ np.tap(randInt(0,2)); }
        }
      } else { // no puzzle left, follow player
        const dx = player.x - a.x, dy = player.y - a.y, d = Math.hypot(dx,dy);
        if(d > 1.5) a.update({vx: dx/d * 0.15, vy: dy/d * 0.15}, map, dt);
      }
    } else {
      const dx = player.x - a.x, dy = player.y - a.y, d = Math.hypot(dx,dy);
      if(d > 1.6) a.update({vx: dx/d * 0.15, vy: dy/d * 0.15}, map, dt);
      else if(Math.random() < 0.01) a.update({vx:(Math.random()-0.5)*0.2, vy:(Math.random()-0.5)*0.2}, map, dt);
    }
  });

  // chaser
  chaser.update([player, ...allies], map, dt);

  // capture check
  if(!player.caught && Math.hypot(player.x - chaser.x, player.y - chaser.y) < 0.9){
    player.caught = true; AudioManager.playSfx('caught'); endGame(false); return;
  }

  // expire tile locks
  tileLocks = tileLocks.filter(l=> l.expires > performance.now());

  // camera (pixel offsets from player iso pos)
  camera.x = (player.x - player.y) * TILE/2 - canvasW/2;
  camera.y = (player.x + player.y) * TILE/4 - canvasH/3;

  // render
  render();

  // check win
  if(puzzles.every(p=>p.solved)) { endGame(true); return; }

  requestAnimationFrame(loop);
}

/* -------------------------
   RENDER
   ------------------------- */
function render(){
  ctx.clearRect(0,0,canvasW,canvasH);

  // draw map tiles & obstacles
  map.draw(ctx, camera);

  // draw actors
  allies.forEach(a=> a.draw(ctx, camera));
  player.draw(ctx, camera);
  chaser.draw(ctx, camera);

  // tile locks
  for(const l of tileLocks){
    const s = isoToScreen(l.x, l.y, camera);
    ctx.fillStyle = 'rgba(120,0,0,0.6)';
    ctx.fillRect(s.x - 8, s.y - 8, 16, 16);
  }

  // darkness overlay + vision
  ctx.save();
  ctx.fillStyle = 'rgba(0,0,0,0.55)';
  ctx.fillRect(0,0,canvasW,canvasH);
  ctx.globalCompositeOperation = 'destination-out';
  // base sight circle
  const sp = isoToScreen(player.x, player.y, camera);
  ctx.beginPath(); ctx.arc(sp.x, sp.y, 160, 0, Math.PI*2); ctx.fill();
  // flashlight cone
  if(player.flashlight && player.battery > 0){
    const ang = player._facingAngle || 0;
    const radius = 350;
    const half = Math.PI / 5;
    ctx.beginPath(); ctx.moveTo(sp.x, sp.y); ctx.arc(sp.x, sp.y, radius, ang-half, ang+half); ctx.closePath(); ctx.fill();
  }
  ctx.globalCompositeOperation = 'source-over';
  ctx.restore();

  // puzzle overlay if any puzzle active -> show overlay on top
  const activePuzzle = puzzles.find(p=>p.active && !p.solved);
  if(activePuzzle){
    activePuzzle.drawOverlay(ctx, canvasW, canvasH);
  }
  // update puzzles left display
  document.getElementById('pLeft').textContent = puzzles.filter(p=>!p.solved).length;
}

/* -------------------------
   END GAME
   ------------------------- */
function endGame(win){
  running = false;
  const overlay = document.createElement('div');
  overlay.style.position='fixed'; overlay.style.inset='0'; overlay.style.zIndex='400';
  overlay.style.display='flex'; overlay.style.alignItems='center'; overlay.style.justifyContent='center';
  overlay.style.background='linear-gradient(180deg, rgba(0,0,0,0.7), rgba(0,0,0,0.95))';
  overlay.innerHTML = `<div style="background:rgba(255,255,255,0.03);padding:18px;border-radius:12px;color:#fff;text-align:center">
    <h2 style="margin:0 0 8px 0">${win ? '逃走者の勝利！' : '追跡者の勝利'}</h2>
    <div style="margin:8px 0 12px 0">「タイトルへ戻る」で最初の画面に戻ります</div>
    <div><button id="backTitle" class="smallBtn">タイトルへ戻る</button></div>
  </div>`;
  document.body.appendChild(overlay);
  document.getElementById('backTitle').addEventListener('click', ()=>{
    document.body.removeChild(overlay);
    // reset minimal state and show start screen
    map = null; player = null; allies = []; chaser = null; puzzles = []; tileLocks = [];
    document.getElementById('startScreen').style.display = 'flex';
  });
}

/* -------------------------
   Start: ensure portrait overlay visibility
   ------------------------- */
document.getElementById('portraitOverlay').style.display = (canvasW > canvasH) ? 'none' : 'flex';

</script>
</body>
</html>