<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Mansion Prototype v3</title>
<style>
  html,body{height:100%; margin:0; background:#000; overflow:hidden; -webkit-user-select:none; user-select:none;}
  canvas{display:block;}
  #ui {
    position:absolute; left:10px; top:8px; z-index:20; color:#fff; font-family:system-ui, sans-serif;
  }
  #ui button { margin-right:6px; padding:6px 8px; font-size:14px; }
  #interact {
    position:absolute; right:16px; bottom:90px; z-index:20;
  }
  #interact button { padding:12px 16px; font-size:16px; border-radius:8px; }
  #rotateWarning {
    position:absolute; inset:0; display:flex; align-items:center; justify-content:center;
    color:#fff; background:#000; font-size:18px; z-index:30;
  }
</style>
</head>
<body>

<div id="ui">
  <button id="aiBtn">鬼AI停止</button>
  <button id="resetBtn">リセット</button>
  <span id="status">パズル未解除</span>
</div>
<div id="interact" style="display:none;">
  <button id="inspectBtn">調べる</button>
</div>

<div id="rotateWarning">横画面でプレイしてください</div>
<canvas id="game"></canvas>

<script>
/* ---------- 基本設定 ---------- */
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

let W = window.innerWidth, H = window.innerHeight;
function resize(){
  W = canvas.width = window.innerWidth;
  H = canvas.height = window.innerHeight;
  // スティックベース位置更新
  stick.baseX = 120;
  stick.baseY = H - 120;
  checkOrientation();
}
window.addEventListener('resize', resize);
resize();

function checkOrientation(){
  if(window.innerWidth > window.innerHeight){
    document.getElementById('rotateWarning').style.display = 'none';
  } else {
    document.getElementById('rotateWarning').style.display = 'flex';
  }
}

/* ---------- ワールド ---------- */
const worldSize = 30;   // グリッド数
const tile = 48;        // タイルスケール（描画上の比率）
const maxX = worldSize - 1;
const maxY = worldSize - 1;

let camera = {x:0,y:0};
let obstacles = [];
let puzzleTile = {x: Math.floor(worldSize*0.6), y: Math.floor(worldSize*0.5)};
let triangles = []; // パズル三角形角度配列

function genObstacles(){
  obstacles = [];
  for(let i=0;i<28;i++){
    // 適度にプレイヤー・敵・パズル付近を避ける
    let ox, oy, tries=0;
    do{
      ox = Math.floor(Math.random()*worldSize);
      oy = Math.floor(Math.random()*worldSize);
      tries++;
    }while((Math.abs(ox-puzzleTile.x)<2 && Math.abs(oy-puzzleTile.y)<2) && tries<10);
    obstacles.push({x:ox+0.0,y:oy+0.0});
  }
}
function genPuzzle(){
  triangles = [
    {angle: Math.floor(Math.random()*4)*90},
    {angle: Math.floor(Math.random()*4)*90},
    {angle: Math.floor(Math.random()*4)*90}
  ];
}
genObstacles();
genPuzzle();

/* ---------- エンティティ ---------- */
let player = {x:2, y:2, speed:0.12};   // ワールド座標
let enemy  = {x:20, y:22, speed:0.07};
let aiActive = true;

/* ---------- 仮想スティック（固定表示・可動域制限） ---------- */
const stick = {
  active:false,
  baseX:120,
  baseY: H - 120,
  dx:0, dy:0,
  radius: 60  // 可動域
};

// タッチ／マウス対応（左側のみスティック操作）
function onPointerStart(x,y){
  // スティックは常に表示。タッチ開始が左半分なら操作を有効化
  if(x < W*0.6){ // 左側で始めると操作（右はUI用）
    stick.active = true;
    // keep base position fixed
    stick.dx = Math.max(-stick.radius, Math.min(stick.radius, x - stick.baseX));
    stick.dy = Math.max(-stick.radius, Math.min(stick.radius, y - stick.baseY));
  }
}
function onPointerMove(x,y){
  if(!stick.active) return;
  let nx = x - stick.baseX;
  let ny = y - stick.baseY;
  const len = Math.hypot(nx, ny);
  if(len > stick.radius){
    nx = (nx/len) * stick.radius;
    ny = (ny/len) * stick.radius;
  }
  stick.dx = nx; stick.dy = ny;
}
function onPointerEnd(){
  stick.active = false;
  stick.dx = 0; stick.dy = 0;
}

canvas.addEventListener('touchstart', e=>{ e.preventDefault(); const t=e.touches[0]; onPointerStart(t.clientX, t.clientY); });
canvas.addEventListener('touchmove', e=>{ e.preventDefault(); const t=e.touches[0]; onPointerMove(t.clientX, t.clientY); });
canvas.addEventListener('touchend', e=>{ e.preventDefault(); onPointerEnd(); });
canvas.addEventListener('mousedown', e=>{ onPointerStart(e.clientX, e.clientY); });
window.addEventListener('mousemove', e=>{ onPointerMove(e.clientX, e.clientY); });
window.addEventListener('mouseup', e=>{ onPointerEnd(); });

/* ---------- UIボタン（継続） ---------- */
const aiBtn = document.getElementById('aiBtn');
const resetBtn = document.getElementById('resetBtn');
const statusEl = document.getElementById('status');
const inspectWrap = document.getElementById('interact');
const inspectBtn = document.getElementById('inspectBtn');

aiBtn.addEventListener('click', ()=>{ aiActive = !aiActive; aiBtn.innerText = aiActive ? '鬼AI停止' : '鬼AI再開'; });
resetBtn.addEventListener('click', resetGame);
inspectBtn.addEventListener('click', ()=>{ if(canInspect()) openPuzzle(); });

function resetGame(){
  player.x=2; player.y=2;
  enemy.x=20; enemy.y=22;
  genObstacles();
  genPuzzle();
  statusEl.innerText = 'パズル未解除';
  puzzleOpened = false;
}

/* ---------- 移動・衝突・カメラ ---------- */
function clampEntity(e){
  e.x = Math.max(0, Math.min(maxX, e.x));
  e.y = Math.max(0, Math.min(maxY, e.y));
}

// iso描画変換（ワールド -> スクリーン）
function iso(x,y){
  return {
    x: (x - y) * tile/2 - camera.x + W/2,
    y: (x + y) * tile/4 - camera.y + H/3
  };
}

/* ---------- パズルロジック ---------- */
let puzzleOpened = false;
function canInspect(){
  // 近ければ表示
  const dx = player.x - puzzleTile.x;
  const dy = player.y - puzzleTile.y;
  return Math.hypot(dx,dy) < 1.6;
}
function openPuzzle(){
  puzzleOpened = true;
}
function closePuzzle(){
  puzzleOpened = false;
  // 成功判定は individual rotation handler will set status
}
function checkPuzzleSolved(){
  // 正解は angle % 360 == 0 for all
  if(triangles.every(t => ((t.angle % 360) + 360)%360 === 0 )){
    statusEl.innerText = 'パズル解除成功！';
    puzzleOpened = false;
  }
}

/* ---------- 入力（パズル上でのタップ） ---------- */
canvas.addEventListener('click', function(e){
  if(!puzzleOpened) return;
  const mx = e.clientX;
  const my = e.clientY;
  // 3つの三角形は中央に横並びで配置。幅120 each, centered.
  const centerX = W/2;
  const startX = centerX - 180;
  for(let i=0;i<3;i++){
    const bx = startX + i*180;
    const by = H/2;
    // simple bounding box detect
    if(mx > bx - 60 && mx < bx + 60 && my > by - 60 && my < by + 60){
      // rotate that triangle 90 deg
      triangles[i].angle = (triangles[i].angle + 90) % 360;
      checkPuzzleSolved();
      return;
    }
  }
});

/* ---------- 更新ループ ---------- */
function update(){
  // カメラはプレイヤーに追従（ワールド中心座標をカメラに）
  camera.x = (player.x - player.y) * tile/2;
  camera.y = (player.x + player.y) * tile/4;

  // プレイヤー移動（スティック）
  if(stick.active){
    const len = Math.hypot(stick.dx, stick.dy);
    if(len > 6){
      // スクリーン方向 -> ワールド方向の近似変換
      // dx_screen corresponds to movement in x-y space:
      // approximate: world_dx = (dx_screen / (tile/2) + dy_screen / (tile/4)) * factor
      const sx = stick.dx;
      const sy = stick.dy;
      // convert screen vector back to grid vector (approx)
      const world_dx = ( sx / (tile/2) + sy / (tile/4) ) * 0.005;
      const world_dy = ( -sx / (tile/2) + sy / (tile/4) ) * 0.005;
      player.x += world_dx * (player.speed*60); // scale to feel right
      player.y += world_dy * (player.speed*60);
    }
  }

  // 衝突：障害物（簡易当たり判定）
  for(const o of obstacles){
    if(Math.abs(player.x - o.x) < 0.8 && Math.abs(player.y - o.y) < 0.8){
      // push back slightly opposite of movement
      const nx = player.x - o.x;
      const ny = player.y - o.y;
      const l = Math.hypot(nx,ny) || 0.001;
      player.x += (nx/l)*0.02;
      player.y += (ny/l)*0.02;
    }
  }

  // ワールド内に限定
  clampEntity(player);

  // 鬼AI：単純追跡（ゼロ除算保護）
  if(aiActive){
    let dx = player.x - enemy.x;
    let dy = player.y - enemy.y;
    let dist = Math.hypot(dx,dy);
    if(dist < 0.001) dist = 0.001;
    enemy.x += (dx/dist) * enemy.speed;
    enemy.y += (dy/dist) * enemy.speed;
    clampEntity(enemy);
  }

  // 探索用：マップ端に出るのを描画上で防ぐ（カメラクランプ）
  const maxCamX = (maxX - 0) * tile/2;
  const minCamX = (0 - maxY) * tile/2;
  camera.x = Math.max(minCamX, Math.min(maxCamX, camera.x));
}

/* ---------- 描画ルーチン ---------- */
function draw(){
  ctx.clearRect(0,0,W,H);

  // タイル地面（簡易）
  for(let x=0;x<worldSize;x++){
    for(let y=0;y<worldSize;y++){
      const p = iso(x,y);
      ctx.fillStyle = ((x+y)%2===0) ? '#141414' : '#161616';
      ctx.fillRect(p.x, p.y, tile/2, tile/4);
    }
  }

  // 障害物
  for(const o of obstacles){
    const p = iso(o.x, o.y);
    ctx.fillStyle = '#4a4a4a';
    ctx.fillRect(p.x - 10, p.y - 30, 40, 30);
    // small highlight
    ctx.fillStyle = '#666';
    ctx.fillRect(p.x - 6, p.y - 26, 12, 6);
  }

  // パズルマーカー（ワールド上）
  if(!puzzleOpened){
    const pz = iso(puzzleTile.x, puzzleTile.y);
    ctx.fillStyle = 'gold';
    ctx.fillRect(pz.x - 10, pz.y - 24, 28, 28);
    // 小三角を描く（向きは 0）
    ctx.fillStyle = '#222';
    ctx.beginPath();
    ctx.moveTo(pz.x+4, pz.y-22);
    ctx.lineTo(pz.x-6, pz.y+4);
    ctx.lineTo(pz.x+14, pz.y+4);
    ctx.closePath();
    ctx.fill();
  }

  // プレイヤー（簡易ドット風）
  const pp = iso(player.x, player.y);
  // body
  ctx.fillStyle = '#27f0f0';
  ctx.fillRect(pp.x - 12, pp.y - 28, 24, 24);
  // head (eye)
  ctx.fillStyle = '#fff';
  ctx.fillRect(pp.x - 6, pp.y - 36, 12, 8);
  ctx.fillStyle = '#000';
  ctx.fillRect(pp.x - 2, pp.y - 34, 4, 4);

  // 追跡者（鬼）デザイン
  const ep = iso(enemy.x, enemy.y);
  ctx.fillStyle = '#ff3b3b';
  ctx.fillRect(ep.x - 12, ep.y - 28, 24, 24);
  ctx.fillStyle = '#000';
  ctx.fillRect(ep.x - 8, ep.y - 36, 16, 8);
  ctx.fillStyle = '#ffebeb';
  ctx.fillRect(ep.x - 4, ep.y - 34, 3, 4);
  ctx.fillRect(ep.x + 1, ep.y - 34, 3, 4);

  // スティック（常時表示、画像風）
  // base circle
  ctx.globalAlpha = 0.35;
  ctx.beginPath();
  ctx.arc(stick.baseX, stick.baseY, stick.radius, 0, Math.PI*2);
  ctx.fillStyle = '#ffffff';
  ctx.fill();
  ctx.globalAlpha = 1.0;
  // inner (neutral)
  ctx.beginPath();
  ctx.strokeStyle = '#eee';
  ctx.lineWidth = 3;
  ctx.arc(stick.baseX, stick.baseY, 34, 0, Math.PI*2);
  ctx.stroke();
  // knob
  const knobX = stick.baseX + stick.dx;
  const knobY = stick.baseY + stick.dy;
  ctx.beginPath();
  ctx.fillStyle = '#fff';
  ctx.arc(knobX, knobY, 26, 0, Math.PI*2);
  ctx.fill();

  // 簡易ライト（プレイヤー周り）
  const g = ctx.createRadialGradient(pp.x, pp.y-10, 30, pp.x, pp.y-10, 300);
  g.addColorStop(0, 'rgba(0,0,0,0)');
  g.addColorStop(1, 'rgba(0,0,0,0.85)');
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  // 調べるボタン表示判定
  if(canInspect() && !puzzleOpened){
    inspectWrap.style.display = 'block';
  } else {
    inspectWrap.style.display = 'none';
  }

  // パズルオーバーレイ
  if(puzzleOpened){
    // 暗い背景
    ctx.fillStyle = 'rgba(0,0,0,0.85)';
    ctx.fillRect(0,0,W,H);
    // 三角形群描画（中央）
    const centerX = W/2;
    const startX = centerX - 180;
    for(let i=0;i<3;i++){
      const bx = startX + i*180;
      const by = H/2;
      ctx.save();
      ctx.translate(bx, by);
      ctx.rotate(triangles[i].angle * Math.PI/180);
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.moveTo(0, -48);
      ctx.lineTo(-40, 36);
      ctx.lineTo(40, 36);
      ctx.closePath();
      ctx.fill();
      ctx.restore();

      // ボックス表示
      ctx.strokeStyle = '#666';
      ctx.strokeRect(bx - 60, by - 60, 120, 120);
      ctx.fillStyle = '#ddd';
      ctx.font = '14px sans-serif';
      ctx.fillText('Tap to rotate', bx - 36, by + 80);
    }
  }
}

/* ---------- ゲームループ ---------- */
function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();

</script>
</body>
</html>